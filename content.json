{"meta":{"title":"TheSakura's Blog","subtitle":null,"description":null,"author":"chenxiang","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about-me","text":"","path":"about-me/index.html"},{"title":"categories","text":"","path":"categories/index.html"},{"title":"tags","text":"","path":"tags/index.html"}],"posts":[{"title":"设计模式","text":"设计模式学习[toc] 设计模式和原则单一职责的原则简单的说就是软件模块应该只有一个被修改的理由。例如Spring中，我们需要有dao 层和service层，而不是把它放在一起，这样后面数据库增加字段，或者业务逻辑更改的时候就不需要修改很多东西，更容易维护。 开闭原则就是在一个模块完成的之后，就不要去改变它，最好是通过继承和多态来增加功能。所以开闭就是，对外的拓展开放，对外的修改闭合。 里氏替换原则简单的说就是尽量不要重写父类的方法，最好是只新增功能，子类可以拓展父类的功能，但是不能改变 如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。 例如几维鸟虽然生物学上是鸟，但是不会飞，如果在计算飞行的一些行为的时候，设计成继承鸟类，最后会出现错误，因此最好仔细考虑他们的继承关系，去除继承关系。 接口隔离原则接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。 要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。 接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。 依赖倒置原则依赖倒置原则的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。 由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。 使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。 在实际编程中只要遵循以下4点，就能在项目中满足这个规则。每个类尽量提供接口或抽象类，或者两者都具备。变量的声明类型尽量是接口或者是抽象类。任何类都不应该从具体类派生。使用继承时尽量遵循里氏替换原则。 创建型模式","path":"2020/06/03/设计模式/"},{"title":"ART算法实现与理解","text":"Code 这两个图显示了算法的原理，整体的几何意义也较为容易理解···import numpy as npdef ARTMy( A, b, X0, e0): e=e0+1 i=0 while(e&gt;e0): tmp=((A[i]@X0-b[i])/(np.linalg.norm(A[i]))*(A[i].T/np.linalg.norm(A[i]))) X=X0-np.reshape(tmp,(-1,1)) e=np.linalg.norm(X-X0) X0=X i=(i+1)%np.shape(A)[0] print(e) return X0if name==”_main“: A=np.array([[3,1],[1,5]]) b=np.array([[1],[1]]) e0=0.000001 X0=np.array([[0],[0]]) X=ART_My(A,b,X0,e0) print((X)) ···","path":"2020/06/03/ART算法实现与理解/"},{"title":"函数间隔和几何间隔","text":"对同一个超平面，通过比例缩放w和b，函数间隔也会同比例变化。也就是说，对于一个成功划分正负实例的超平面（不一定最优），该平面固定，但是通过缩放w和b，可以使其function margin取任何正值。而我们的目标是找到具有最大margin的超平面。显然通过最大化函数间隔没有意义，因为任何成功划分训练实例的超平面都可以使函数间隔无限大。我们注意到，对一个超平面，函数间隔与∥w∥的比值保持不变，也就是说几何间隔与超平面关联。所以，我们目标是最大化几何间隔，而且我们可以令函数间隔为1，然后最小化∥w∥达到最大化几何间隔目的。 SVM是通过超平面将样本分为两类。在超平面wx+b确定的情况下，||wx+b||可以相对地表示点距离超平面的远近。对于两类分类问题，如果wx+b&gt;0，可视为在平面上方，则的类别被判定为1；否则判定为-1。所以样本点与超平面之间的函数间隔定义为y(wx+b),但是该定义存在问题：即w和x同时缩小或放大M倍后，超平面并没有变化，但是函数间隔却变化了。w是法向量，所以，需要将w的大小固定,使得函数间隔固定。这时的间隔也就是几何间隔 。","path":"2020/05/21/函数间隔和几何间隔/"},{"title":"大端和小端","text":"字节存储顺序主要分为大端序（Big-endian）和小端序（Little-endian），区别如下Big-endian：高位字节存入低地址，低位字节存入高地址Little-endian：低位字节存入低地址，高位字节存入高地址一般来说，x86系列CPU都是Little-endian字节序，PowerPC通常是Big-endian字节序。 因为网络协议也都是采用Big-endian方式传输数据的，所以有时也把Big-endian方式称为网络字节序","path":"2020/05/20/大端和小端/"},{"title":"218. 天际线问题","text":"问题的求解方法一其实我们在题目标签看到了Line Sweep，[ 线扫描或扫描线 ] ，扫描线可以想象成一条向右扫过平面的竖直线，也是一个算法，一般是玩图形学的。 接着上面的步骤，可以通过扫描线算法将两个关键点集合进行合并。 如下图，扫描线从两个集合的起始点，同时向右移动，接触到第一个关键点，则判断这一个关键点是不是满足天际线的，如果是，则将这个关键点添加到“父”集合中；如果不是，则继续同时移动到下一个关键点。 但如何判断是否是属于“父”集合中的关键点呢？可以创建两个集合（“子”）的目前高度，然后多方角度找到满足关键点的条件。 扫描线移到[2 10]关键点时，10要大于rpre的，可以满足； 扫描线移到[3 15]关键点时，lpre此时目前的高度为10，而15要大于10的，可以满足； 扫描线移到[7 10]关键点时，rpre大于lpre可以满足，反之就不满足； 接着有一个集合已经遍历完了，剩下的集合的关键点肯定是满足的，因为没有其它的集合可以阻挡到这个集合，所以直接就是满足。 这个求解方法中的归并的写法比我以前写的要简洁一些，值得学习。这个问题的求解方法的重点在于合并两个点，合并过程中首先选择一个集合的小的，然后判断其与当前另外一个集合的当前值的关于，如果大于则一定可以加进去，因为这个值和自身高度同样也不同如果小于等于并且自身当前高度要大于另外一个集合的当前值，则可以加，否则就被盖住实际是看不到的。 在相等的情况下，我们应该考虑到相同X的位置的最高位置的不能和和此时的当前的最大位置相同，如果相同实际上是形成了一条直线，是看不到的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; getSkyline(int[][] buildings) &#123; List&lt;List&lt;Integer&gt;&gt; res&#x3D;new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(buildings.length&#x3D;&#x3D;0) return res; return divide(buildings,0,buildings.length-1); &#125; public List&lt;List&lt;Integer&gt;&gt; divide(int [][]buildings,int l,int r) &#123; List&lt;Integer&gt; list&#x3D;new ArrayList&lt;Integer&gt;(); List&lt;List&lt;Integer&gt;&gt; res&#x3D;new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(r&#x3D;&#x3D;l) &#123; res.add(Arrays.asList(buildings[l][0],buildings[l][2])); res.add(Arrays.asList(buildings[l][1],0)); return res; &#125; int a&#x3D;l+(r-l)&#x2F;2; List&lt;List&lt;Integer&gt;&gt; res1&#x3D;divide(buildings,l,a); List&lt;List&lt;Integer&gt;&gt; res2&#x3D;divide(buildings,a+1,r); int l1&#x3D;0; int r1&#x3D;0; int lh&#x3D;0,rh&#x3D;0; int leftX, leftY, rightX, rightY; while(l1&lt;res1.size()||r1&lt;res2.size()) &#123; if(l1&gt;&#x3D;res1.size()) res.add(res2.get(r1++)); else if(r1&gt;&#x3D;res2.size()) res.add(res1.get(l1++)); else &#123; leftX &#x3D; res1.get(l1).get(0); &#x2F;&#x2F; 不会出现null，可以直接用int类型 leftY &#x3D; res1.get(l1).get(1); rightX &#x3D; res2.get(r1).get(0); rightY &#x3D; res2.get(r1).get(1); if(leftX&gt;rightX)&#x2F;&#x2F;每次选择一个较小的 &#123; if(rightY&gt;lh) res.add(res2.get(r1)); else if(rh&gt;lh) &#123; res.add(Arrays.asList(rightX,lh)); &#125; rh&#x3D;rightY; r1++; &#125; else if(leftX&lt;rightX) &#123; if(leftY&gt;rh) res.add(res1.get(l1)); else if(lh&gt;rh) res.add(Arrays.asList(leftX,rh)); lh&#x3D;leftY; l1++; &#125; else &#123; int h&#x3D;Math.max(lh,rh); if(leftY&gt;&#x3D;rightY&amp;&amp;leftY!&#x3D;h) &#123; res.add(res1.get(l1)); &#125; else if(leftY&lt;&#x3D;rightY&amp;&amp;rightY!&#x3D;h)&#x2F;&#x2F;只要不汇聚到最高点就没问题 &#123; res.add(res2.get(r1)); &#125; lh&#x3D;leftY; rh&#x3D;rightY; l1++; r1++; &#125; &#125; &#125; return res; &#125;&#125; 这个方法是扫面线算法，方法较为巧妙，左上和右上节点分别设置为负数和正数，从左加入右先队列，从右边删除出，然后每次和最大的节点进行比较，不同就加入节点。这里的java的容器的比较器的写法是o2-o1，大于0就是顺序，否则逆序。 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; getSkyline(int[][] buildings) &#123; List&lt;List&lt;Integer&gt;&gt; res&#x3D;new ArrayList&lt;List&lt;Integer&gt;&gt;(); Set&lt;Pair&lt;Integer,Integer&gt;&gt; pairs&#x3D;new TreeSet&lt;&gt;((o1,o2)-&gt;!o1.getKey().equals(o2.getKey())?o1.getKey()-o2.getKey():o1.getValue()-o2.getValue()); for(int[] bu:buildings) &#123; pairs.add(new Pair&lt;&gt;(bu[0],-bu[2])); pairs.add(new Pair&lt;&gt;(bu[1],bu[2])); &#125; PriorityQueue&lt;Integer&gt; queue&#x3D;new PriorityQueue&lt;&gt;((o1,o2)-&gt;o2-o1); int prev &#x3D; 0; &#x2F;&#x2F; 遍历 for (Pair&lt;Integer, Integer&gt; pair : pairs) &#123; if (pair.getValue() &lt; 0) queue.offer(-pair.getValue()); &#x2F;&#x2F; 左端点 高度入堆 else queue.remove(pair.getValue()); &#x2F;&#x2F; 右端点 高度出堆 Integer cur &#x3D; queue.peek() &#x3D;&#x3D; null ? 0 : queue.peek(); &#x2F;&#x2F; 获取最大堆的当前顶点，当null时置为0 if (prev !&#x3D; cur) &#123; res.add(new ArrayList&lt;Integer&gt;() &#123; &#123; add(pair.getKey()); add(cur); &#125;&#125;); prev &#x3D; cur; &#125; &#125; return res; &#125; &#125;","path":"2020/05/20/218. 天际线问题/"},{"title":"为啥那么C++pop不返回值","text":"书上的解释也就是说，为什么先用top（），然后用pop（）来访问和删除站定的元素，而不是把它们合并一个返回类型T的成员函数。 这种设计有很好的理由。如果pop（）返回栈顶元素，则必须按值返回，而不是按引用返回。按引用返回是不可行的，因为元素 在栈中已经不存在，必须在按引用返回之前现将其存储到某个地方。如果选用动态内存，除非动态内存最终被删除，否则将导致内存泄露。 按照数值返回效率很差，因为它包含对类型T的复制构造函数的调用。让pop（）返回数值将会导致潜在的内存问题或效率很低下， 因此最好让它什么数值也不返回，而是通过使用top（）来得到栈顶的数值。 从异常上看这么使用 Stack stack; stack.push(object); Object obj=stack.pop() ; 当我们执行Object obj=stack.pop() 时，Object的构造函数被调用，而这里是可以反生异常的， 假设这时候发生异常，丢生的栈顶元素就回不去了。 而在java中pop（）是有返回值的源码是这么写的 int i = size(); Object object = peek(); removeElementAt(i - 1); return (E)object; 实质上java进行对象赋值的时候是进行引用的。但是C++是进行一个复制构造函数的调用，","path":"2020/05/20/为什么C++pop不返回值/"},{"title":"145. 二叉树的后序遍历","text":"方法后序遍历的麻烦之处在于不知道现在自己是父节点的左节点还是右节点，只有知道才能决定下一步是访问右节点还是根节点，不知道的情况下就不清楚下一步应该访问弹出的栈元素的本身还是它的右节点。而前序遍历和中序遍历是总是只需要弹出栈中的元素，然后访问其右节点即可或者先访问自己再访问其右节点。 所以方法有三种： 开始的话，也是不停的往左子树走，然后直到为 null ，然后如果集合中没有栈顶元素，并且右子树不为空，那么我们就访问栈顶元素的右节点，并把栈顶元素加入集合中，如果集合中有，那么直接访问栈顶元素即可。1234567891011121314151617181920212223242526272829303132class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res&#x3D;new ArrayList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; stack&#x3D;new Stack&lt;TreeNode&gt;(); Set&lt;TreeNode&gt; set&#x3D;new HashSet&lt;TreeNode&gt;(); TreeNode treenode&#x3D;root; while(!stack.isEmpty()||treenode!&#x3D;null) &#123; if(treenode!&#x3D;null) &#123; stack.push(treenode); treenode&#x3D;treenode.left; &#125; else &#123; TreeNode tmp&#x3D;stack.peek(); if(!set.contains(tmp)&amp;&amp;tmp.right!&#x3D;null) &#123; treenode&#x3D;tmp.right; set.add(tmp); &#125; else &#123; res.add(tmp.val); stack.pop(); &#125; &#125; &#125; return res; &#125;&#125; 如果当前节点的右节点和上一次遍历的节点相同，那就表明当前是从右节点过来的了1234567891011121314151617181920212223242526272829303132class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res&#x3D;new ArrayList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; stack&#x3D;new Stack&lt;TreeNode&gt;(); TreeNode treenode&#x3D;root; TreeNode last&#x3D;null; while(!stack.isEmpty()||treenode!&#x3D;null) &#123; if(treenode!&#x3D;null) &#123; stack.push(treenode); treenode&#x3D;treenode.left; &#125; else &#123; TreeNode tmp&#x3D;stack.peek(); if(tmp.right!&#x3D;null&amp;&amp;tmp.right!&#x3D;last) &#123; treenode&#x3D;tmp.right; &#125; else &#123; res.add(tmp.val); last&#x3D;tmp; stack.pop(); &#125; &#125; &#125; return res; &#125;&#125; 只需要把每个节点 push 两次，然后判断当前 pop 节点和栈顶节点是否相同。相同的话，就意味着是从左子树到的根节点。不同的话，就意味着是从右子树到的根节点，此时就可以把节点加入到 list 中。这个方法比较巧妙123456789101112131415161718192021222324 public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;(); if (root &#x3D;&#x3D; null) &#123; return list; &#125; Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;(); stack.push(root); stack.push(root); while (!stack.isEmpty()) &#123; TreeNode cur &#x3D; stack.pop(); if (cur &#x3D;&#x3D; null) &#123; continue; &#125; if (!stack.isEmpty() &amp;&amp; cur &#x3D;&#x3D; stack.peek()) &#123; stack.push(cur.right); stack.push(cur.right); stack.push(cur.left); stack.push(cur.left); &#125; else &#123; list.add(cur.val); &#125; &#125; return list;&#125; 可以转换成一个逆的前序遍历来实现12345678910111213141516171819202122public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res&#x3D;new ArrayList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; stack&#x3D;new Stack&lt;TreeNode&gt;(); TreeNode treenode&#x3D;root; while(!stack.isEmpty()||treenode!&#x3D;null) &#123; if(treenode!&#x3D;null) &#123; res.add(treenode.val); stack.add(treenode); treenode&#x3D;treenode.right; &#125; else &#123; treenode&#x3D;stack.pop().left; &#125; &#125; Collections.reverse(res); return res;&#125;","path":"2020/05/19/145. 二叉树的后序遍历/"},{"title":"232. 用栈实现队列","text":"双栈实现队列，思路较为简单 ···class MyQueue { private Stack stack1; private Stack stack2; /* Initialize your data structure here. / public MyQueue() { stack1=new Stack(); stack2=new Stack(); } /** Push element x to the back of queue. */ public void push(int x) { stack1.push(x); } /** Removes the element from in front of queue and returns that element. */ public int pop() { if(stack2.isEmpty()) { StackMove(stack1,stack2); } int res=stack2.peek(); stack2.pop(); return res; } /** Get the front element. */ public int peek() { if(stack2.isEmpty()) { StackMove(stack1,stack2); } int res=stack2.peek(); return res; } /** Returns whether the queue is empty. */ public boolean empty() { return stack1.isEmpty()&amp;&amp;stack2.isEmpty(); } public void StackMove(Stack&lt;Integer&gt; stack1,Stack&lt;Integer&gt; stack2) { if(stack2.isEmpty()) { while(!stack1.isEmpty()) { int a=stack1.peek(); stack2.push(a); stack1.pop(); } } } } /** Your MyQueue object will be instantiated and called as such: MyQueue obj = new MyQueue(); obj.push(x); int param_2 = obj.pop(); int param_3 = obj.peek(); boolean param_4 = obj.empty();*/···","path":"2020/05/19/232. 用栈实现队列/"},{"title":"225. 用队列实现栈","text":"队列实现栈主要是栈的pop操作比较困难，这个可以通过栈的循环出队入队来实现，复杂度为O(N)。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class MyStack &#123; private Queue&lt;Integer&gt; quene&#x3D;new LinkedList&lt;Integer&gt;(); private int mytop&#x3D;0; &#x2F;** Initialize your data structure here. *&#x2F; public MyStack() &#123; &#125; &#x2F;** Push element x onto stack. *&#x2F; public void push(int x) &#123; quene.offer(x); mytop&#x3D;x; &#125; &#x2F;** Removes the element on top of the stack and returns that element. *&#x2F; public int pop() &#123; for(int i&#x3D;0;i&lt;quene.size()-1;i++) &#123; int a&#x3D;quene.poll(); quene.offer(a); if(i&#x3D;&#x3D;quene.size()-2) mytop&#x3D;a; &#125; return quene.poll(); &#125; &#x2F;** Get the top element. *&#x2F; public int top() &#123; if(!quene.isEmpty()) return mytop; else return 0; &#125; &#x2F;** Returns whether the stack is empty. *&#x2F; public boolean empty() &#123; if(quene.size()&#x3D;&#x3D;0) return true; else return false; &#125;&#125;&#x2F;** * Your MyStack object will be instantiated and called as such: * MyStack obj &#x3D; new MyStack(); * obj.push(x); * int param_2 &#x3D; obj.pop(); * int param_3 &#x3D; obj.top(); * boolean param_4 &#x3D; obj.empty(); *&#x2F;","path":"2020/05/19/225. 用队列实现栈/"},{"title":"linux短横线的区别","text":"linux短横线的区别1234567rm -vf ***tar -xzvf ***.tar.gzgcc --versionrm --help 从上面命令我们可以看出，绝大数命令有以下的规则： ① 参数前单杠的表明后面的参数是字符形式； ② 参数前双杠的则表明后面的参数是单词形式 123tar xzvf ***.tar.gztar -xzvf ***.tar.gz 两种命令行都是行的通的，并且功能都是解压软件包，那它们到底有什么不同呢，实际上这就涉及两种Linux风格，System V和BSD。它们对应关系如下： ① 参数前有横的是System V风格。 ② 参数前没有横的是BSD风格。 System V和BSD两种风格的区别主要是： 系统启动过程中 kernel 最后一步调用的是 init 程序，init 程序的执行有两种风格，即 System V 和 BSD。 System V 风格中 init 调用 /etc/inittab，BSD 风格调用 /etc/rc，它们的目的相同，都是根据 runlevel 执行一系列的程序。","path":"2020/05/18/linux短横线的区别/"},{"title":"224. 基本计算器","text":"方法1和方法二：只有加减的话，相当于去掉括号，去掉括号的过程就是，把数字和字符串弹出，然后计算的过程，这个方法比较麻烦，应该可以采用字符串反向便利的方式进行计算，这样计算表达式就要方便很多，从左到右算就可以，如果还有乘除之类的话，那么在过程中应该还要判断字符的优先级，然后进行计算,还有一个需要注意的就是，数字可能有很多位。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182方法一：class Solution &#123; public int calculate(String s) &#123; Stack &lt;Integer&gt; op1&#x3D;new Stack &lt;Integer&gt;();&#x2F;&#x2F;数字栈 Stack&lt;Character&gt; op2&#x3D;new Stack&lt;Character&gt;();&#x2F;&#x2F;字符栈 int t&#x3D;0; int flag&#x3D;1;&#x2F;&#x2F;正在记录数字 for(int i&#x3D;0;i&lt;s.length();i++) &#123; Character ch&#x3D;s.charAt(i); if(flag&#x3D;&#x3D;0&amp;&amp;!Character.isDigit(ch)) &#123; op1.push(t); System.out.println(t); flag&#x3D;1; t&#x3D;0; &#125; if(Character.isDigit(ch)) &#123; flag&#x3D;0; int num&#x3D;(int)(ch-&#39;0&#39;); t&#x3D;t*10+num; &#125; else if(ch.equals(&#39;-&#39;)||ch.equals(&#39;+&#39;)||ch.equals(&#39;(&#39;)) &#123; op2.push(ch); &#125; else if(ch.equals(&#39;)&#39;)) &#123; op1.push(CalFormula(op1,op2)); &#125; &#125; if(flag&#x3D;&#x3D;0) &#123; op1.push(t); System.out.println(t); flag&#x3D;1; t&#x3D;0; &#125; return CalFormula(op1,op2); &#125; public int CalFormula(Stack &lt;Integer&gt; op1 , Stack&lt;Character&gt; op2) &#123; Stack &lt;Integer&gt; op3&#x3D;new Stack &lt;Integer&gt;();&#x2F;&#x2F;数字栈 Stack&lt;Character&gt; op4&#x3D;new Stack&lt;Character&gt;();&#x2F;&#x2F;字符栈 while(!op2.isEmpty()&amp;&amp;!op2.peek().equals(&#39;(&#39;)) &#123; op3.push(op1.peek()); op1.pop(); op4.push(op2.peek()); op2.pop(); &#x2F;&#x2F; System.out.println(op2.peek()); &#125; op3.push(op1.peek()); op1.pop(); if(!op2.isEmpty()&amp;&amp;op2.peek().equals(&#39;(&#39;)) op2.pop(); while(!op4.isEmpty()) &#123; int a&#x3D;op3.peek(); op3.pop(); int b&#x3D;op3.peek(); op3.pop(); char c&#x3D;op4.peek(); op4.pop(); op3.push(cal(c,a,b)); &#125; return op3.peek(); &#125; public int cal(Character ch,Integer num,Integer num1) &#123; if(ch.equals(&#39;-&#39;)) return num-num1; else return num+num1; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869方法2：class Solution &#123; public int calculate(String s) &#123; Stack &lt;Integer&gt; op1&#x3D;new Stack &lt;Integer&gt;();&#x2F;&#x2F;数字栈 Stack&lt;Character&gt; op2&#x3D;new Stack&lt;Character&gt;();&#x2F;&#x2F;字符栈 Integer t&#x3D;0; StringBuffer nu&#x3D;new StringBuffer(&quot;&quot;); int flag&#x3D;1;&#x2F;&#x2F;正在记录数字 StringBuffer a&#x3D;new StringBuffer(s); String str&#x3D;a.reverse().toString(); for(int i&#x3D;0;i&lt;str.length();i++) &#123; Character ch&#x3D;str.charAt(i); if(flag&#x3D;&#x3D;0&amp;&amp;!Character.isDigit(ch)) &#123; t&#x3D;Integer.parseInt(nu.reverse().toString()); op1.push(t); flag&#x3D;1; nu&#x3D;new StringBuffer(&quot;&quot;); &#125; if(Character.isDigit(ch)) &#123; nu.append(ch); flag&#x3D;0; &#125; else if(ch.equals(&#39;-&#39;)||ch.equals(&#39;+&#39;)||ch.equals(&#39;)&#39;)) &#123; op2.push(ch); &#125; else if(ch.equals(&#39;(&#39;)) &#123; CalFormula(op1,op2); &#125; &#125; if(flag&#x3D;&#x3D;0) &#123; t&#x3D;Integer.parseInt(nu.reverse().toString()); op1.push(t); &#125; return CalFormula(op1,op2); &#125; public int CalFormula(Stack &lt;Integer&gt; op1 , Stack&lt;Character&gt; op2) &#123; Stack &lt;Integer&gt; op3&#x3D;new Stack &lt;Integer&gt;();&#x2F;&#x2F;数字栈 Stack&lt;Character&gt; op4&#x3D;new Stack&lt;Character&gt;();&#x2F;&#x2F;字符栈 while(!op2.isEmpty()&amp;&amp;!op2.peek().equals(&#39;)&#39;)) &#123; int a&#x3D;op1.peek(); op1.pop(); int b&#x3D;op1.peek(); op1.pop(); Character c&#x3D;op2.peek(); op2.pop(); op1.push(cal(c,a,b)); &#125; if(!op2.isEmpty()&amp;&amp;op2.peek().equals(&#39;)&#39;)) op2.pop(); return op1.peek(); &#125; public int cal(Character ch,Integer num,Integer num1) &#123; if(ch.equals(&#39;-&#39;)) return num-num1; else return num+num1; &#125;&#125; 方法三采用一种双栈的方法，解法一经过了一个中间过程，先转为了后缀表达式然后进行求值。我们其实可以直接利用两个栈，边遍历边进行的，这个方法是我当时上课学的方法。从 这里 把过程贴到下边，和解法一其实有些类似的。 使用两个栈，stack0 用于存储操作数，stack1 用于存储操作符从左往右扫描，遇到操作数入栈 stack0遇到操作符时，如果当前优先级低于或等于栈顶操作符优先级，则从 stack0 弹出两个元素，从 stack1 弹出一个操作符，进行计算，将结果并压入stack0，继续与栈顶操作符的比较优先级。如果遇到操作符高于栈顶操作符优先级，则直接入栈 stack1遇到左括号，直接入栈 stack1。遇到右括号，则从 stack0 弹出两个元素，从 stack1 弹出一个操作符进行计算，并将结果加入到 stack0 中，重复这步直到遇到左括号和解法一一样，因为我们只有加法和减法，所以这个流程可以简化一下。 第 3 条改成「遇到操作符时，则从 stack0 弹出两个元素进行计算，并压入stack0，直到栈空或者遇到左括号，最后将当前操作符压入 stack1 」处。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687class Solution &#123; public int calculate(String s) &#123; Stack &lt;Integer&gt; op1&#x3D;new Stack &lt;Integer&gt;();&#x2F;&#x2F;数字栈 Stack&lt;Character&gt; op2&#x3D;new Stack&lt;Character&gt;();&#x2F;&#x2F;字符栈 HashMap&lt;Character,Integer&gt; map&#x3D;new HashMap&lt;Character,Integer&gt;(); map.put(&#39;+&#39;,1); map.put(&#39;-&#39;,1); map.put(&#39;(&#39;,-1); Integer t&#x3D;0; int flag&#x3D;1; Character ch; for(int i&#x3D;0;i&lt;s.length();i++) &#123; ch&#x3D;s.charAt(i); if(flag&#x3D;&#x3D;0&amp;&amp;!Character.isDigit(ch)) &#123; op1.push(t); t&#x3D;0; flag&#x3D;1; &#125; if(Character.isDigit(ch)) &#123; flag&#x3D;0; t&#x3D;t*10+(int)(ch-&#39;0&#39;); &#125; else if(ch.equals(&#39;-&#39;)||ch.equals(&#39;+&#39;)) &#123; flag&#x3D;1; while(!op2.isEmpty()&amp;&amp;!(map.get(op2.peek())&lt;map.get(ch))) &#123; int a&#x3D;op1.peek(); op1.pop(); int b&#x3D;op1.peek(); op1.pop(); Character c&#x3D;op2.peek(); op2.pop(); op1.push(cal(c,b,a)); &#125; op2.push(ch); &#125; else if(ch.equals(&#39;(&#39;)) &#123; flag&#x3D;1; op2.push(ch); &#125; else if(ch.equals(&#39;)&#39;)) &#123; flag&#x3D;1; while(!op2.isEmpty()&amp;&amp;!op2.peek().equals(&#39;(&#39;)) &#123; int a&#x3D;op1.peek(); op1.pop(); int b&#x3D;op1.peek(); op1.pop(); Character c&#x3D;op2.peek(); op2.pop(); op1.push(cal(c,b,a)); &#125; op2.pop(); &#125; &#125; if(flag&#x3D;&#x3D;0) &#123; op1.push(t); &#125; while(!op2.isEmpty()) &#123; int a&#x3D;op1.peek(); op1.pop(); int b&#x3D;op1.peek(); op1.pop(); Character c&#x3D;op2.peek(); op2.pop(); op1.push(cal(c,b,a)); &#125; return op1.peek(); &#125; public int cal(Character ch,Integer num,Integer num1) &#123; if(ch.equals(&#39;-&#39;)) return num-num1; else return num+num1; &#125;&#125;","path":"2020/05/18/224. 基本计算器/"},{"title":"统计学习方法课后作业","text":"第九章EM算法及其推广123456789101112131415161718192021222324252627282930319.1import numpy as npy&#x3D;[1,1,0,1,0,0,1,0,1,1]pai&#x3D;0.46p&#x3D;0.55q&#x3D;0.67theta&#x3D;2while(theta&gt;0.0001): u_next&#x3D;[] for i in range(len(y)): a&#x3D;pai*(p**y[i])*((1-p)**(1-y[i])) b&#x3D;(1-pai)*(q**y[i])*((1-q)**(1-y[i])) u_next.append(a&#x2F;(a+b)) pai_next&#x3D;0 p_next&#x3D;0 q_next&#x3D;0 tmp&#x3D;0 pai_next&#x3D;np.mean(u_next) p_next &#x3D; sum(np.multiply(u_next,y))&#x2F;sum(u_next) tmp&#x3D;[1-u_next[i] for i in range(len(y))] q_next &#x3D; sum(np.multiply(tmp,y))&#x2F;sum(tmp) print(pai_next) print(p_next) print(q_next) print(&quot;\\n&quot;) theta&#x3D;abs(pai_next-pai)+abs(p_next-p)+abs(q_next-q) pai&#x3D;pai_next p&#x3D;p_next q&#x3D;q_next 求得123456780.4618628351139190.53459500378501120.65613464178573260.461862835113919070.53459500378501120.6561346417857326","path":"2020/05/18/统计学习方法课后作业/"},{"title":"神经网络初始化与xavier初始化","text":"xavier初始化 深度学习初始化总结","path":"2020/05/18/神经网络初始化与xavier初始化/"},{"title":"矩阵的范数","text":"关于矩阵的范数的一些总结 一范数，二范数，闵可夫斯基范数这些都比较常见，一般不用多说 核范数代表矩阵的奇异值之和，是用来约束低秩的一种范数，代表rank(w)的凸近似。 ||X||_*=\\sum_{i}^{}\\sigma_i(x)F范数即为就是对应元素的平方和再开方。f范数实际上就是衡量这个矩阵和对应的零矩阵的距离，","path":"2020/05/18/矩阵的范数/"},{"title":"矩阵求导","text":"参考文章","path":"2020/05/18/矩阵求导/"},{"title":"在hexo博客中写数学公式","text":"这个网站值得借鉴","path":"2020/05/18/在hexo博客中写数学公式/"},{"title":"图像的k空间","text":"关于图像的k空间到底是什么意思呢，总的来说就算傅里叶域变换后的一种图，不能让人感性的感受到图，但是经过傅里叶反变换，总是能够变回原来的图像具体可见下面两篇博客k空间k空间","path":"2020/05/18/图像的k空间/"},{"title":"矩阵的TV最小化","text":"在一个图像处理问题中如何有效的去除图像的噪声可以求解这样一个问题最小化图像的TV,TV即为梯度图像的一范数，当然需要加上正则化项，如果不加的化，全黑图才是最优的一个解，加上正则化之后可以获得图像的分块光滑图像，事实证明，效果很好。","path":"2020/05/18/TV最小化/"},{"title":"softmax和SVM损失函数","text":"softmax可以参考softmax可以参考 softmax可以参考1主要要理解熵的原理，以及交叉熵。以及softmax的正则化的内容 SVM损失函数可以参考SVM损失函数可以参考1主要是要比正确分类的类别多出一个边界出来","path":"2020/05/18/softmax和SVM损失函数/"},{"title":"Numpy中矩阵与向量的加法","text":"在Numpy中，矩阵与向量相加时，矩阵的每一行与向量相加，即要求矩阵的列数与向量的维数相等。1234567891011121314import numpy as npx &#x3D; np.array([[1, 2, 3], [4, 5, 6]])# array([[1, 2, 3],# [4, 5, 6]])y &#x3D; np.array([1, 2])# array([1, 2])z &#x3D; np.array([1, 2, 3])# array([1, 2, 3])# x + y 会报错x + z# array([[2, 4, 6],# [5, 7, 9]])","path":"2020/05/18/numpy矩阵加法/"},{"title":"matlab并行","text":"parfor matlab用法1matlab会弄出几个虚拟的小pc，一个算i&#x3D;1:30部分循环,一个算i&#x3D;50:80部分循环,再来一个算i&#x3D;90:120部分循环，当然数字是我瞎编的，我是想说matlab将一个大循环分成小块，然后这些小块并行计算，最后再合在一起。这样，有一个问题，因为普通的循环是从i&#x3D;1算到i&#x3D;100，一个接一个算，如果下一次循环要依赖上一次循环怎么办？如果出现这种情况，那就不能用matlab的parfor了。用parfor的前提条件就是，循环的每次迭代独立，不相互依赖。举个简单的例子，计算1+2+3...+100就可以用parfor，但是如果计算斐波那契数列的前100个数字，那就不能用parfor了。","path":"2020/05/18/matlab并行/"},{"title":"makedown数学公式写法","text":"此网站可以查看公式写法","path":"2020/05/18/makedown数学公式写法/"},{"title":"conda 安装 pytorch","text":"关于conda安装pytorch的一些问题的总结 使用conda安装pytorch较为简单在pytorch官网选择自己需要的版本，以及是否带gpu的，我的由于是没有gpu的，所以是1conda install pytorch torchvision cpuonly -c pytorch 但是下载的速度会很慢，而且会出现httperror,这时可以考虑更换源，选择国内的镜像源，例如清华的镜像更换镜像1234conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --set show_channel_urls yesconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ 测试是否安装成功1import torch 成功后代表安装成功 更多信息: 我的博客","path":"2020/05/18/hello-world/"},{"title":"使用github+hexo部署博客","text":"可见这篇博客 更多信息: 我的博客","path":"2020/05/18/github+hexo博客搭建/"},{"title":"图像生成","text":"可以参考这个博客图像生成cs231 同时这个人还总结了cs231的很多内容，可以都参考一下","path":"2020/05/18/cs231图像生成/"}],"categories":[],"tags":[]}