{"meta":{"title":"TheSakura's Blog","subtitle":null,"description":null,"author":"chenxiang","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about-me","text":"","path":"about-me/index.html"},{"title":"categories","text":"","path":"categories/index.html"},{"title":"tags","text":"","path":"tags/index.html"}],"posts":[{"title":"排序算法稳定性","text":"堆排序、快速排序、希尔排序、直接选择排序是不稳定的排序算法，而基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序是稳定的排序算法。首先，排序算法的稳定性大家应该都知道，通俗地讲就是能保证排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。在简单形式化一下，如果Ai = Aj, Ai原来在位置前，排序后Ai还是要在Aj位置前。其次，说一下稳定性的好处。排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就 是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。回到主题，现在分析一下常见的排序算法的稳定性，每个都给出简单的理由。 (1)冒泡排序冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改 变，所以冒泡排序是一种稳定排序算法。 (2)选择排序选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个 元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么 交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9， 我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。 (3)插入排序插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开 始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相 等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳 定的。 (4)快速排序快速排序有两个方向，左边的i下标一直往右走，当a[i] &lt;= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] &gt; a[center_index]。如果i和j都走不动了，i &lt;= j, 交换a[i]和a[j],重复上面的过程，直到i&gt;j。 交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11， 现在中枢元素5和3(第5个元素，下标从1开始计)交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。 (5)归并排序归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素(认为直接有序)或者2个元素(1次比较和交换),然后把各个有序的段序列合并成一个有 序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定 性。那么，在短的有序序列合并的过程中，稳定是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结 果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。 (6)基数排序基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优 先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。 (7)希尔排序(shell)希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比o(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元 素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。 (8)堆排序我们知道堆的结构是节点i的孩子为2i和2i+1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第n/2开始和其子节点共3个值选择最大(大顶堆)或者最小(小顶堆),这3个元素之间的选择当然不会破坏稳定性。但当为n /2-1, n/2-2, …1这些个父节点选择元素时，就会破坏稳定性。有可能第n/2个父节点交换把后面一个元素交换过去了，而第n/2-1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。综上，得出结论: 选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，而冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法。","path":"2020/07/21/排序算法稳定性/"},{"title":"桶排序基数排序相关题目","text":"164. 最大间距桶排序第一种方法采用的是桶排序，方法很巧妙。我们可以知道比较排序最好都是nlogn的，所以不能使用，使用桶排序让我们忽略桶中的顺序，只比较桶之间的大小就可以获得On的复杂度。 那么怎么得到呢，可以得到max,min 然后如果有n个，取一个比平均距离小的内容，为（max-min）/（n）+1,其实也可以加三加四都可以，只需要保证桶内的距离比平均距离小，插值一定在桶间取到就可以，如果每个每个桶的大小对平均距离向下取整，那么相差最大的两个值一定不会在桶中。所以我们只需要记录桶的最大值和最小值，然后比较桶之间的距离就行了。 int maximumGap(vector&lt;int&gt;&amp; nums) &#123; int len=nums.size(); if(len&lt;2) return 0; vector&lt;int&gt; maxnum(len,-1); vector&lt;int&gt; minnum(len,-1); int maxval=-1,minval=nums[0]; for(int i=0;i&lt;len;i++) &#123; if(nums[i]&gt;maxval) maxval=nums[i]; if(nums[i]&lt;minval) minval=nums[i]; &#125; int sizen=(maxval-minval)/(len)+1; for(int i=0;i&lt;len;i++) &#123; int t=(nums[i]-minval)/sizen; if(nums[i]&gt;maxnum[t]) maxnum[t]=nums[i]; if(minnum[t]==-1||nums[i]&lt;minnum[t]) minnum[t]=nums[i]; // cout&lt;&lt;minnum[t]&lt;&lt;\" \"&lt;&lt;maxnum[t]&lt;&lt;\" \"&lt;&lt;t&lt;&lt;endl; &#125; int res=0; int tmp=-1; for(int i=0;i&lt;len;i++) &#123; if(maxnum[i]==-1) continue; if(tmp==-1) &#123; tmp=maxnum[i]; continue; &#125; if(minnum[i]-tmp&gt;res) &#123; res=minnum[i]-tmp; // cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;minnum[i]&lt;&lt;\" \"&lt;&lt;tmp&lt;&lt;\" \"&lt;&lt;res&lt;&lt;endl; &#125; tmp=maxnum[i]; &#125; return res; &#125; 164. 最大间距基数排序基数排序这个是从低位到高位很适合，复杂度是d(n+k),d是位数，k是基数10.这个以前不理解为啥低位到高位可行，其实原因是因为这样是稳定的，例如一个44，41，52.个位数排41，52，44排好，然后排个位就是41，44，52，为什么41一定在前面呢，就是因为，个位的时候已经在前面了，所以要保持稳定性，下次还是在前面。 class Solution &#123; public: int maximumGap(vector&lt;int&gt;&amp; nums) &#123; int len=nums.size(); if(len&lt;2) return 0; vector&lt;int&gt; t(len); vector&lt;vector&lt;int&gt;&gt; res(10,t); int maxnum=-1; for(int i=0;i&lt;len;i++) &#123; maxnum=max(maxnum,nums[i]); &#125; int e=1; while(maxnum!=0) &#123; for(int i=0;i&lt;10;i++) res[i].clear(); for(int i=0;i&lt;len;i++) &#123; int t=nums[i]/e%10; res[t].push_back(nums[i]); &#125; int index=0; for(int i=0;i&lt;10;i++) &#123; for(int j=0;j&lt;res[i].size();j++) &#123; nums[index]=res[i][j]; index++; &#125; &#125; maxnum/=10; e*=10; &#125; int result=0; for(int i=1;i&lt;len;i++) &#123; result=max(result,nums[i]-nums[i-1]); &#125; return result; &#125; &#125;;","path":"2020/07/21/桶排序基数排序相关题目/"},{"title":"C++中取INF","text":"int型是4个字bai节 一个字节8个位 0x7f7f7f7f 是十六进制du也就是4个0x7f ,一个0x7f 转化为二进制就zhi是 01111111因为是int型 第一个位是符号位dao ，因而在int 型中 0x7f7f7f7f也就是无穷大的意思通过 #define 将 “INF” 转化为符号常量 代表 0x7f7f7f7f","path":"2020/07/17/C++中取INF/"},{"title":"计数排序基数排序和桶排序","text":"计数排序基数排序和桶排序 这三种方法我经常容易忘记，不太熟悉。总结一下。 计数排序原理很容易懂就是排序元素的范围我们知道，那么就可以将其放到一个这么大的数组中，然后直接每次从数组中取数丢进排序数组中，这个不是一个比较排序的方法。最坏时间复杂度为O(n+k),空间复杂度也为O(n+k) 空间复杂度容易理解，但是时间复杂度我一开始以为的是O(n),实际上这是不对的，因为需要考虑到n很小而k很大 n很大而k很小的情况，综合起来就是O(n+k). 桶排序假设:它使用了具有固定范围的“桶”。它假设每一个元素都会落在这些桶内。每一个桶的范围是固定的。如果桶的范围是1，则该算法就与计数排序很相似了，唯一的不同之处是，它存储的是元素本身而不是它们的计数。 算法： 假设有k个桶：B0, B1, … Bk-1 对于数组a中的每一个元素e： 当e属于Bi时，将其插入Bi中 对于B中的每一个桶b： sort b 令finalarray = {} 对于B中的每一个桶b： finalarray = concat(finalarray, b) 时间复杂度：O(n)，最坏情况O(n n)或者O(n logn)取决于其对桶使用的排序算法。最坏情况下所有元素都落入同一个桶内。 其时间复杂度还与桶的大小和范围有关。如果桶的大小和范围选择不当，可能使得所有元素都落入同一个桶中。如果元素均匀的分布在各个桶内，则时间复杂度就是O(n) 空间复杂度：O(n) 大体讲就是将数分到很多个桶中，每个桶中的排序复杂度很小，然后将数连起来。排序完成，最坏情况大家都在一个桶中效果就很差。 基数排序基数排序的主要思路是,将所有待比较数值(注意,必须是正整数)统一为同样的数位长度,数位较短的数前面补零. 然后, 从最低位开始, 依次进行一次稳定排序(我们常用上一篇blog介绍的计数排序算法, 因为每个位可能的取值范围是固定的从0到9).这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列. 基数排序的时间复杂度是O(n*k)，其中n是排序元素的底，如是十进制就是10，k是数字位数。","path":"2020/07/13/计数排序基数排序和桶排序/"},{"title":"背包九讲","text":"背包九讲01背包问题有 N 件物品和一个容量为 V 的背包。放入第 i 件物品耗费的费用是 Ci1，得到的价值是 Wi。求解将哪些物品装入背包可使价值总和最大。递推方程应该是res[i][V]=max(res[i-1][V-ci]+wi,res[i-1][V]); 可以用滚动数组优化成O(V)空间 这个空间优化的过程，应该逆序得到，顺序不可以。 res[V]=max(res[V-ci],res[V]); V=V……1；还可以进行常数优化res[V]=max(res[V-ci],res[V]); $a_1$ $V=V……max(V-\\sum^{n}_{i+1}ci+1,ci)$ 为什么是循环到i+1就可以停下来呢？如果是ci较大，那么对于一维空间优化的情况下，表示的是res[i-1][V],对于继续向下循环是不会改变结果的。 如果是V-\\sum^{n}_{i+1}ci+1较大，说明剩下的空间已经不够装ci了，自然也没必要再继续了。 完全背包问题有 N 种物品和一个容量为 V 的背包，每种物品都有无限件可用。放入第 i 种物品的费用是 Ci，价值是 Wi。求解：将哪些物品装入背包，可使这些物品的耗费的费用总和不超过背包容量，且价值总和最大。 这个题目一看很容易认为是贪心问题，但是这个物品是不能分的所以不是贪心的，需要注意。这个我们考虑的就是还是某个物品选不选，但是是可以再次选它的。 二维形式 res[i][V]=max(res[i-1][V],res[i][V-ci]+wi); 一维形式为res[V]=max(res[V],res[V-ci]+wi) v=1……V;在优化的情况下，体积大于V可以直接去掉。O(n) 另外对于任何的体积更大的，但是价值更低的，也可以优化掉。O(n^2) 还可以将体积相同的物品，都用其价值最大的代替。O(V+N)类似计数排序 for i……n if(store[V[i]]&lt;wi) store[V[i]]=wifor i ……v 把这些物品丢进去 多重背包问题有 N 种物品和一个容量为 V 的背包。第 i 种物品最多有 Mi 件可用，每件耗费的空间是 Ci，价值是 Wi。求解将哪些物品装入背包可使这些物品的耗费的空间总和不超过背包容量，且价值总和最大。 这个首先有两个朴素的想法 01背包的想法这个想法是把M[i]个相同的物品看成很多个不同的物品，然后用01背包方法求解。 完全背包的想法这个方法就是对于任何一个物品，每次都有许多个选择，然后选取其中的k个进行空间优化之后和01背包的思路相同。复杂度也相同int mutibackpack()//类似完全背包的方法 &#123; for (int i = 0; i &lt;N; i++) &#123; for (int j = 1; j &lt;=M[i]; j++) &#123; for (int k = C[i]*j; k &lt;=V; k++) &#123; res[k] =max(res[k], res[k-j*C[i]]+j*W[i]); &#125; &#125; &#125; return res[V]; &#125; 二进制优化二进制思想： 假设有 1000 个苹果，现在要取n个苹果，如何取？朴素的做法应该是将苹果一个一个拿出来，直到n个苹果被取出来。再假设有 1000 个苹果和10只箱子，利用箱子进行某些预工作，然后如何快速的取出n个苹果呢？So..可以在每个箱子中放 2^i (i&lt;=0&lt;=n)个苹果，也就是 1、2、4、8、16、32、64、128、256、489（n减完之前的数之后不足 2^i，取最后剩余的数），相当于把十进制的数用二进制来表示，取任意n个苹果时，只要推出几只箱子就可以了。 再次分析： 只看上面是不好理解的，比如：7的二进制 7 = 111, 它可以分解成 001, 010, 100. 这三个数可以组合成任意小于等于 7 的数，而且每种组合都会得到不同的数。再比如，13 = 1101, 则分解为 0001, 0010, 0100, 0110. 前三个数字可以组合成 7 以内任意一个数，每个数再加上0110(= 6) 之后可以组合成任意一个大于等于 6 小于等于 13 的数，所以依然能组成任意小于等于 13 的数，很明显 6,7 会多重复 1 次，但对于求解背包问题是没有影响的，基于这种思想把一种多件物品转换为，多件一种物品，然后用01背包求解即可。 这个想法可以视为从以前我们对于某种物品取它的n数量，会考虑n-1数量的情况，现在我们不是间隔为1进行考虑，而是用二进制的方法来考虑int mutibackpack2()//二进制优化 &#123; int ste = 1; int num; for (int i = 0; i &lt; N; i++) &#123; num = M[i]; while(num&gt;0) &#123; if(num&gt;ste) num -= ste; else &#123; ste = num; num -= ste; &#125; for (int k = C[i] * ste; k &lt;= V; k++) &#123; res[k] = max(res[k], res[k - ste * C[i]] + ste * W[i]); &#125; ste *= 2; &#125; &#125; return res[V]; &#125; 可行性问题多重背包可行性问题指的是：每种有若干件的物品能否填满给定容量的背包，此时不考虑价值最大问题 F(i,j)表示使用前i个物品，填充容量为jjj的背包，第i个物品最多能够剩余多少个，如果无法填充容量为j的背包，则值为-1. F[i-1][j]&gt;0res[i][j]=M[i] F[i][j-C[i]]&lt;=0 || j&lt;C[i]res[i][j]=-1 其他res[i][j]=res[i][j-C[i]]-1 int mutibackpack3()//res[i][j]表示前i中物品填满j大小的空间最大的剩余物品数量,进行了空间优化 &#123; res[0] = M[0]; for (int i = 0; i &lt; V; i++) &#123; res[V] = -1; &#125; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; V; j++) &#123; if (res[j] &gt; 0) res[j] = M[i]; else if (res[j - C[i]] &lt;= 0 || j &lt; C[i]) res[j] = -1; else res[j] = res[j - W[i]] - 1; &#125; &#125; return res[V]; &#125; 单调队列求解这个比较难，暂时没写 混合背包问题01 背包与完全背包的混合考虑到 01 背包和完全背包中给出的伪代码只有一处不同，故如果只有两类物品：一类物品只能取一次，另一类物品可以取无限次，那么只需在对每个物品应用转移方程时，根据物品的类别选用顺序或逆序的循环即可，复杂度是 O(V N)。 再加上多重背包如果再加上最多可以取有限次的多重背包式的物品，那么利用单调队列，也可以给出均摊 O(V N) 的解法。但如果不考虑单调队列算法的话，用将每个这类物品分成 O(logMi) 个 01 背包的物品的方法也已经很优了。最清晰的写法是调用我们前面给出的三个过程。 二维费用的背包问题二维费用的背包问题是指：对于每件物品，具有两种不同的费用，选择这件物品必须同时付出这两种费用。对于每种费用都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设第 i 件物品所需的两种费用分别为 Ci 和 Di。两种费用可付出的最大值（也即两种背包容量）分别为 V 和 U。物品的价值为 Wi。 算法可以写成res[i][j][k]=max(res[i-1][j][k],res[i][j-ci][k-di]+2i) 有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取 U 件物品。这事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为 1，可以付出的最大件数费用为 U。换句话说，设 F[v, u] 表示付出费用 v、最多选 u 件时可得到的最大价值，则根据物品的类型（01、完全、多重）用不同的方法循环更新，最后在f[0 . . . V, 0 . . . U] 范围内寻找答案。 分组背包有 N 件物品和一个容量为 V 的背包。第 i 件物品的费用是 Ci，价值是 Wi。这些物品被划分为 K 组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 这个问题变成了每组物品有若干种策略：是选择本组的某一件，还是一件都不选。也就是说设 F[k, v] 表示前 k 组物品花费费用 v 能取得的最大权值 res[k][v]=max(res[k-1][v],res[k][v-c[i]]+wi),ci,wi 为组中的东西 依赖背包这个问题由 NOIP2006 中“金明的预算方案”一题扩展而来。遵从该题的提法，将不依赖于别的物品的物品称为“主件”，依赖于某主件的物品称为“附件”。由这个问题的简化条件可知所有的物品由若干主件和依赖于每个主件的一个附件集合组成。按照背包问题的一般思路，仅考虑一个主件和它的附件集合。可是，可用的策略非常多，包括：一个也不选，仅选择主件，选择主件后再选择一个附件，选择主件后再选择两个附件……无法用状态转移方程来表示如此多的策略。事实上，设有 n 个附件，则策略有 2n + 1 个，为指数级。 考虑到所有这些策略都是互斥的（也就是说，你只能选择一种策略），所以一个主件和它的附件集合实际上对应于依赖背包中的一个物品组，每个选择了主件又选择了若干个附件的策略对应于这个物品组中的一个物品，其费用和价值都是这个策略中的物品的值的和。但仅仅是这一步转化并不能给出一个好的算法，因为物品组中的物品还是像原问题的策略一样多。 再考虑对每组内的物品应用完全背包中的优化。我们可以想到，对于第 k 个物品组中的物品，所有费用相同的物品只留一个价值最大的，不影响结果。所以，可以对主件 k 的“附件集合”先进行一次 01 背包，得到费用依次为 0. . .V − Ck 所有这些值时相应的最大价值 Fk[0 . . . V − Ck]。那么，这个主件及它的附件集合相当于 V − Ck + 1 个物品的物品组，其中费用为 v 的物品的价值为 Fk[v − Ck] + Wk，v 的取值范围是 Ck ≤ v ≤ V 。 也就是说，原来指数级的策略中，有很多策略都是冗余的，通过一次 01 背包后，将主件 k 及其附件转化为 V − Ck + 1 个物品的物品组，就可以直接应用6的算法解决问题了。 在树形依赖的背包问题中，我们将每颗子树作为一个泛化物品来看。同样，我们可以对每个主件的附件集合进行处理，合成一个新的泛化物品。即对每个主件的附件集合做一次01背包，得到res[j],j为0……v-wi,wi为第i个主件的空间，表示该附件集合在分配体积为j的情况下该附件总和的最优值。 更一般的问题是：依赖关系以图论中“森林”3的形式给出。 也就是说，主件的附件仍然可以具有自己的附件集合。限制只是每个物品最多只依赖于一个物品（只有一个主件）且不出现循环依赖。解决这个问题仍然可以用将每个主件及其附件集合转化为物品组的方式。唯一不同的是，由于附件可能还有附件，就不能将每个附件都看作一个一般的 01 背包中的物品了。若这个附件也有附件集合，则它必定要被先转化为物品组，然后用分组的背包问题解出主件及其附件集合所对应的附件组中各个费用的附件所对应的价值。事实上，这是一种树形动态规划，其特点是，在用动态规划求每个父节点的属性之前，需要对它的各个儿子的属性进行一次动态规划式的求值。这已经触及到了“泛化物品”的思想。看完泛化物品后，你会发现这个“依赖关系树”每一个子树都等价于一件泛化物品，求某节点为根的子树对应的泛化物品相当于求其所有儿子的对应的泛化物品之和。 泛化物品考虑这样一种物品，它并没有固定的费用和价值，而是它的价值随着你分配给它的费用而变化。这就是泛化物品的概念。更严格的定义之。在背包容量为 V 的背包问题中，泛化物品是一个定义域为 0 . . . V中的整数的函数 h，当分配给它的费用为 v 时，能得到的价值就是 h(v)。这个定义有一点点抽象，另一种理解是一个泛化物品就是一个数组 h[0 . . . V ]，给它费用 v，可得到价值 h[v]。一个费用为 c 价值为 w 的物品，如果它是 01 背包中的物品，那么把它看成泛化物品，它就是除了 h(c) = w 外，其它函数值都为 0 的一个函数。如果它是完全背包中的物品，那么它可以看成这样一个函数，仅当 v 被 c 整除时有 h(v) = w ·v c，其它函数值均为 0。如果它是多重背包中重复次数最多为 m 的物品，那么它对应的泛化物品的函数有 h(v) = w ·vc 仅当 v 被 c 整除且 vc ≤ n，其它情况函数值均为 0。 一个物品组可以看作一个泛化物品 h。对于一个 0 . . . V 中的 v，若物品组中不存在费用为 v 的物品，则 h(v) = 0，否则 h(v) 取值为所有费用为 v 的物品的最大价值。6中每个主件及其附件集合等价于一个物品组，自然也可看作一个泛化物品。 泛化物品的和如果给定了两个泛化物品 h 和 l，要用一定的费用从这两个泛化物品中得到最大的价值，这个问题怎么求呢？事实上，对于一个给定的费用 v，只需枚举将这个费用如何分配给两个泛化物品就可以了。同样的，对于 0. . .V 中的每一个整数 v，可以求得费用v 分配到 h 和 l 中的最大价值 f(v)。 f(v)=max(h(k)+l(v-k)) k=1……v 由泛化物品的定义可知：在一个背包问题中，若将两个泛化物品代以它们的和，不影响问题的答案。事实上，对于其中的物品都是泛化物品的背包问题，求它的答案的过程也就是求所有这些泛化物品之和的过程。若问题的和为 s，则答案就是 s(0 . . . V ) 中的最大值。 搜索还是DP?在看到一道背包问题时，应该用搜索还是动态规划呢？ 首先，可以从数据范围中得到命题人意图的线索。如果一个背包问题可以用DP解，V一定不能很大，否则O(VN)的算法无法承受，而一般的搜索解法都是仅与N有关，与V无关的。所以，V很大时（例如上百万），命题人的意图就应该是考察搜索。另一方面，N较大时（例如上百），命题人的意图就很有可能是考察动态规划了。 另外，当想不出合适的动态规划算法时，就只能用搜索了。例如看到一个从未见过的背包中物品的限制条件，无法想出DP的方程，只好写搜索以谋求一定的分数了。","path":"2020/07/13/背包九讲/"},{"title":"打家劫舍","text":"粉刷房子1这个题目leetcode需要会员，题干如下。假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。 当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的矩阵来表示的。 例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。请你计算出粉刷完所有房子最少的花费成本。 注意： 所有花费均为正整数。 示例： 输入: [[17,2,17],[16,16,5],[14,3,19]]输出: 10解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。 最少花费: 2 + 5 + 3 = 10。 选取第i个房子涂不同颜色的最小值public int minCostII(vector&lt;vector&lt;int&gt;&gt; costs) &#123; int n=costs.size(); if(n==0) return 0; int a=costs[0][0],b=costs[0][1],c=costs[0][2]; int t1,t2,t3; for(int i=0;i&lt;n;i++) &#123; t1=a; t2=b; t3=c; a=min(b,c)+costs[i][0];//刷成红色的最大值 b=min(t1,t3)+costs[i][1]; c=min(t1,t2)+costs[i][2];//刷成蓝色 &#125; return min((min(a,b)),c); &#125; 粉刷房子2假如有一排房子，共 n 个，每个房子可以被粉刷成 k 种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。 当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x k 的矩阵来表示的。 例如，costs[0][0] 表示第 0 号房子粉刷成 0 号颜色的成本花费；costs[1][2] 表示第 1 号房子粉刷成 2 号颜色的成本花费，以此类推。请你计算出粉刷完所有房子最少的花费成本。 注意： 所有花费均为正整数。 示例： 输入: [[1,5,3],[2,9,4]]输出: 5解释: 将 0 号房子粉刷成 0 号颜色，1 号房子粉刷成 2 号颜色。最少花费: 1 + 4 = 5; 或者将 0 号房子粉刷成 2 号颜色，1 号房子粉刷成 0 号颜色。最少花费: 3 + 2 = 5. 这个题目如果用正常的思路，那么应该是对每个位置的房子，选取不同的颜色k，然后取其颜色不为k最小值。O(nkk). 会导致超时，复杂度过高。 可以优化每次选上一个的最短花费和次短花费。如果颜色和最短花费不一样，则选最短花费，否则选次短花费。这个地方应该注意一点，我之前很迷惑如果最短和次短都是和它一个颜色怎么办呢，后来才发现其实选的是在上一个位置颜色不同的最短花费和次短花费。这个地方比较巧妙，需要额外注意。 public int minCostII(vector&lt;vector&lt;int&gt;&gt; costs,int k) &#123; int n=costs.size(); if(n==0||costs[0].size()==0) return 0; auto res=costs; int tmp1=0,tmp2=1; int a1=-1,a2=-1; for(int i=0;i&lt;n;i++) &#123; a1=-1; a2=-1; for(int j=0;j&lt;k;j++) &#123; if(j==tmp1) &#123; res[i][j]=(i==0?costs[i][j]:res[i-1][tmp1]+costs[i][j]); &#125; else &#123; res[i][j]=(i==0?costs[i][j]:res[i-1][tmp2]+costs[i][j]); &#125; if(a2&lt;0||res[i][j]&lt;res[i][a2]) &#123; a2=j; if(a2&lt;0||res[i][a2]&lt;res[i][a1]) &#123; swap(a2,a1); &#125; &#125; &#125; tmp1=a1; tmp2=a2; &#125; return res[n-1][tmp1]; &#125;","path":"2020/07/13/粉刷房子/"},{"title":"打家劫舍","text":"打家劫舍1递推公式为d0[i]=d1[i-1]+price,d1[i]=max(d1[i-1],d0[i-1]);可以进行空间优化class Solution &#123; public: int rob(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()==0) return 0; int a=nums[0]; int b=0; int len=nums.size(); int t; for(int i=1;i&lt;len;i++) &#123; t=a; a=b+nums[i]; b=max(b,t); &#125; return max(a,b); &#125; &#125;; 打家劫舍2只需要保证最后一个和第一个不会被同时取到，注意这个不是约瑟夫问题那样可以循环的。所以只需要求两次然后考虑删除第一个和删除最后一个的情况。 int rob(vector&lt;int&gt;&amp; nums) &#123;//不能来回偷 int len=nums.size(); if(len==0) return 0; if(len==1) return nums[0]; vector&lt;int&gt; res1; res1.assign(nums.begin()+1, nums.end()); vector&lt;int&gt; res2; res2.assign(nums.begin(),nums.end()-1); int a=res2[0]; int b=0; int t; for(int i=1;i&lt;len-1;i++) &#123; t=a; a=b+res2[i]; b=max(t,b); &#125; int res=max(a,b); a=res1[0]; b=0; for(int i=1;i&lt;len-1;i++) &#123; t=a; a=b+res1[i]; b=max(t,b); &#125; int tt=max(a,b); return max(res,tt); &#125; 打家劫舍3这个结构是树形的，相比数组的要难一些，所以第一种方法就是考虑根节点偷和不偷的情况，然后返回之，我第一次做是用的递归返回的是偷和随便偷不偷，这样是不行的，应该要明确状态。 vector&lt;int&gt; dp0(TreeNode* root) &#123; vector&lt;int&gt; res(2,0); if(root==nullptr) return res; vector&lt;int&gt; res1=dp0(root-&gt;left); vector&lt;int&gt; res2=dp0(root-&gt;right); res[0]=root-&gt;val+res1[1]+res2[1];//偷这个根节点的选项 res[1]=max(res1[0],res1[1])+max(res2[0],res2[1]);//不偷的选项 return res; &#125; int rob(TreeNode* root) &#123; if(root==nullptr) return 0; vector&lt;int&gt; res=dp0(root); return max(res[0],res[1]); &#125; 事实上确实有一种考虑随便偷不偷的方法的。在区分偷不偷的时候，我们事实上考虑的是偷目前节点加上随便偷不偷孙子节点，以及不偷目前节点，随便偷不偷儿子节点。为了防止超时，用哈希表把求得的信息存起来。unordered_map&lt;TreeNode*,int&gt; m; int dp0(TreeNode* root,unordered_map&lt;TreeNode*,int&gt;&amp; m) &#123; int value=0; if(root==nullptr) return 0; if(m.count(root)) return m[root]; if(root-&gt;left!=nullptr) value+=dp0(root-&gt;left-&gt;left,m)+dp0(root-&gt;left-&gt;right,m); if(root-&gt;right!=nullptr) value+=dp0(root-&gt;right-&gt;left,m)+dp0(root-&gt;right-&gt;right,m); int t=max(root-&gt;val+value,dp0(root-&gt;right,m)+dp0(root-&gt;left,m)); m[root]=t; return t; &#125; int rob(TreeNode* root) &#123; if(root==nullptr) return 0; return dp0(root,m); &#125;","path":"2020/07/13/打家劫舍/"},{"title":"股票买卖问题","text":"股票买卖问题1当前的最大收益只依赖于之前的最小买入价格。只需要记住到目前为止的最小值，然后可以得到每个位置的收益。O(n)class Solution &#123; public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int max=0; int len=prices.size(); if(len==0) return 0; int min=prices[0]; for(int i=0;i&lt;len;i++) &#123; if(prices[i]&gt;min) &#123; int t=prices[i]-min; if(max&lt;t) max=t; &#125; else &#123; min=prices[i]; &#125; &#125; return max; &#125; &#125;; 股票买卖问题2这个题目朴素的想法就是找到每个峰谷和峰顶，然后求差异获得利润。但是由于可以进行多次交易，那么只要明天比今天价格高就有得赚，就可以进行交易。不需要去找波峰波谷，因为day2-day1+day3-day2 == day3-day1 class Solution &#123; public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res=0; int len=prices.size(); for(int i=1;i&lt;len;i++) &#123; if(prices[i]&gt;prices[i-1]) res+=prices[i]-prices[i-1]; &#125; return res; &#125; &#125;; 股票买卖问题3int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int len=prices.size(); if(len==0) return 0; vector&lt;int&gt; res1(3,0); vector&lt;int&gt; res2(3,0); for(int i=0;i&lt;3;i++) res2[i]=-prices[0]; for(int i=1;i&lt;len;i++) &#123; res2[0]=max(res2[0],-prices[i]); for(int j=1;j&lt;=2;j++) &#123; res1[j]=max(res1[j],res2[j-1]+prices[i]); res2[j]=max(res1[j]-prices[i],res2[j]); &#125; &#125; return res1[2]; &#125; 股票买卖问题4买卖k次 当前处于第几天；已经交易的次数；手头是否持有股票；即根据手头是否持有股票，我们定义两个二维数组来定义状态： dp0[i][j]: 第i天结束，已有j次买卖，手头没有股票时的最大利润dp1[i][j]: 第i天结束，已有j次买卖，手头有股票时的最大利润因此，dp0[0][j]对于所有j都要初始化为0，而dp1[0][j]对于所有j都要初始化为-prices[i]。如果我们将dp0所有值都求出来了，那么很明显dp0[n-1][k]就是在最后一天结束时已进行k次交易且手头无股票时的最大收益，也即返回结果。 先看初始状态: 当i==0 &amp;&amp; j&gt;=0: dp0[0][j] = 0, dp1[0][j] = -prices[0];当i&gt;0 &amp;&amp; j==0: dp0[i][0] = 0, dp1[i][0] = max(dp1[i-1][0], -prices[i]);再来考虑状态转移方程，当i&gt;0且j&gt;0时有 dp0[i][j] = max(dp0[i-1][j], dp1[i-1][j-1] + prices[i]) # 保持 or 卖出dp1[i][j] = max(dp1[i-1][j], dp0[i-1][j] - prices[i]) # 保持 or 买入有了状态定义及转移方程，剩下就好办了。 int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int k=2;//可以改变k值 int len=prices.size(); if(len==0) return 0; vector&lt;int&gt; a(k+1,0); vector&lt;vector&lt;int&gt;&gt; res1(len,a);//没有股票在手中 vector&lt;vector&lt;int&gt;&gt; res2(len,a);//有股票在手中 int min=prices[0]; for(int i=0;i&lt;k;i++) res2[0][i]=-prices[0]; for(int i=1;i&lt;len;i++) &#123; res2[i][0]=max(res2[i-1][0],-prices[i]); &#125; for(int i=1;i&lt;len;i++) &#123; for(int j=1;j&lt;=k;j++) &#123; res1[i][j]=max(res1[i-1][j],res2[i-1][j-1]+prices[i]); res2[i][j]=max(res1[i-1][j]-prices[i],res2[i-1][j]); &#125; &#125; return res1[len-1][k]; &#125; 但是这个效率不高，可以知道，当k&gt;2/n的时候。就是买卖无数次了。并且可以进行空间优化。int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; int len=prices.size(); if(len==0||k==0) return 0; if(k&gt;len/2) &#123; int result=0; for(int i=1;i&lt;len;i++) &#123; if(prices[i]&gt;prices[i-1]) result+=prices[i]-prices[i-1]; &#125; return result; &#125; vector&lt;int&gt; res1(k+1,0); vector&lt;int&gt; res2(k+1,0); int min=prices[0]; for(int i=0;i&lt;k;i++) res2[i]=-prices[0]; for(int i=1;i&lt;len;i++) &#123; res2[0]=max(res2[0],-prices[i]); for(int j=1;j&lt;=k;j++) &#123; res1[j]=max(res1[j],res2[j-1]+prices[i]); res2[j]=max(res1[j]-prices[i],res2[j]); &#125; &#125; return res1[k]; &#125; 股票买卖问题5这里需要注意的就是当不持股，不在冷冻期的可能就是，上一个是冷冻期，然后这一天啥也没干，还有可能就是直接就是上一天。int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int len=prices.size(); if(len==0) return 0; vector&lt;int&gt; res1(len,0);//不持股，不在冷冻期 vector&lt;int&gt; res2(len,0);//持股，不在冷冻期 res2[0]=-prices[0]; vector&lt;int&gt; res3(len,0);//不持股，在冷冻期 for(int i=1;i&lt;len;i++) &#123; res1[i]=max(res1[i-1],res3[i-1]); res2[i]=max(res1[i-1]-prices[i],res2[i-1]); res3[i]=res2[i-1]+prices[i]; &#125; return max(res3[len-1],res1[len-1]); &#125; 优化空间 int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int len=prices.size(); if(len==0) return 0; int res1=0;//不持股，不在冷冻期 int res2=-prices[0];//持股，不在冷冻期 int res3=0;//不持股，在冷冻期 for(int i=1;i&lt;len;i++) &#123; int a=res1; int b=res2; res1=max(a,res3); res2=max(a-prices[i],b); res3=b+prices[i]; &#125; return max(res3,res1); &#125; 股票买卖问题6也是和之前的类似，选取两个状态，持有股票，不持有股票，在卖出时还需要减去手续费。 int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123; int len=prices.size(); int res1=0; int res2=-prices[0]; int t; for(int i=0;i&lt;len;i++) &#123; t=res1; res1=max(res1,res2+prices[i]-fee); res2=max(res2,t-prices[i]); &#125; return res1; &#125;","path":"2020/07/12/股票买卖问题/"},{"title":"动态规划题型总结","text":"因为动态规划毕竟要满足： 阶段性无后效性子问题重叠性因此，能够利用DP来解决的问题实际上是有限的，大部分题目都是针对现有的模型的一些变种，改改题目描述，或者加点限制条件。所以要想攻克DP题目，最根本的就是要充分理解几个常见的DP模型。而要充分理解常见经典DP模型，就需要通过大量的做题和总结，而且二者不可偏废。通过做题进行思考和量的积累，通过总结加深理解和融会贯通进而完成质的提升。 动态规划是求解一个最优化问题，而最核心的思想就是： 分而治之想办法记录下中间的计算结果避免重复计算解一道DP题目，先问自己几个问题： 我需要最少哪些数据，然后经过一些比较就能得出最终结果？这些数据的求解是否可以用同样的方法分而治之？过程中的运算结果如何保存复用？当然以上内容看起来比较抽象，虽然它深刻地揭露了动态规划的本质，但是如果临场要去想明白这些问题，还是有些难度。如果只是针对比赛和面试，就像前面说的，DP题型是有限的。只要刷的题目足够多，总结出几个经典模型，剩下的都是些变种+优化而已。 一般来说，动态规划可以分成4个大类: 线性DP数位dp概率dp等区间DP树型DP背包线性DP就是阶段非常线性直观的模型，比如：最长（上升|下降）序列，最长公共子序列(LCS)等，也有一些简单的递推，甚至都算不上是经典模型。 线性dp最长上升序列最长上升序列是一个非常经典的线性模型。说它是个模型，是因为它是一类题的代表，很多题目都只是换个说法，或者要求在这基础上进一步优化而已。最长上升序列最基础的转移方程就是f[i] = max{f[j]}+1 (a[i] &gt; a[j]),f[i]表示一定要以a[i]结尾的序列，最长长度是多少。很显然就是在前面找到一个最大的f[j]同时满足a[j]&lt;a[i]。因此是N^2的时间复杂度和N的空间复杂度。这种方法是最朴素直观的，一定要理解。它非常简单，因此很少有题目直接能够这么做。大部分相关题目需要进一步优化，也就是有名的单调队列优化，能够把复杂度优化到nlogn。相关题目比如： 300. 最长上升子序列，裸题，但是要击败100%的话，需要单调队列优化。 354. 俄罗斯套娃信封问题，这道题还是hard。之前的最长上升序列是一维的，这道题是二维的上升序列，满足Ax&lt;Bx且Ay&lt;By，才可以构成上升序列。那么我们可以根据x进行排序，然后对y求解最长上升子序列。但是这里有个地方需要注意，因为x必须要严格升序，排序之后可能存在(1,1) (1,2) (1,3) (2,4)这样的序列，如果对y进行求解上升序列，会得到4，但是实际应该只是2。为了避免这个问题，在排序时，如果x相等，则y按照降序排列，就可以规避这个问题。 合唱队形，这道题是要求一个形如1 3 4 7 9 8 6 5 2这样的子序列。先上升再下降，最后求最长的长度。其实解决办法也很简单，先从左到右求出所有的最长上升序列asc[i]，再从右到左求出所有的最长上升序列reverseAcc[i]，最大值就是max(asc[i]+reverseAcc[i])。对算法要能够灵活运用。 LCS 最长公共子序列最长公共子序列也是线性DP中的一种比较常见的模型。说它是一种“模型”其实有点拔高了，其实它就是一类比较常见的题目。很多题目都是在LCS的基础上进行简单的扩展，或者仅仅就是换一个说法而已。求两个数组的最长公共子序列，最直观地做法就是：设f[i][j]表示S[..i]和T[..j]的最长公共子序列，则有: f[i][j] = f[i-1][j-1] + 1 …… S[i]==T[j]f[i][j] = max(f[i-1][j], f[i][j-1]) …… S[i]≠T[j]这个转移方程也非常好理解，时间复杂度是N^2，空间复杂度也是N^2。不过仔细观察你可以发现，当我们计算第i行时只与i-1和i行有关。因此我们可以利用01滚动来优化空间复杂度为2N。相关题目： 1143. Longest Common Subsequence：这道题就是裸的LCS 583. Delete Operation for Two Strings：两个字符串要删除成一样的，所以先找出最长公共序列，然后剩下的都删了。 718. Maximum Length of Repeated Subarray：这道题其实本质上不是LCS，它是寻找最长子数组，而不是子序列（子数组要求连续）。需要搞清它们的区别。找子数组就更简单了，因为必须连续，所以f[i][j] = f[i-1][j-1]+1 : 0 ? S[i]==T[j]。通过倒序枚举能够把空间优化为O(N)。 1092. Shortest Common Supersequence：这道题是hard，实际上也不算很hard。其实就是找到最长公共子序列，然后，对于A字符串，把除了LCS以外的字符插入到对应的位置；对于B字符串也做同样的操作。这道题大家需要掌握一个新姿势，就是除了求最长公共子序列有多长，还要会打印最长公共子序列（follow up：打印所有可能的最长公共子序列）。同时，要把剩余的字符插入到对应的位置其实可以想办法把原字符串按照LCS切分成k+1段，比如对于字符串A abcxdef，其lcs为bde，那么我们可以把原字符串切成4段 a bcx d ef，同样对于B字符串，也能切成4段，然后对应插入构成新字符串即可，需要注意的就是，从第1段开始，第一个字符是lcs字符，所以只插一次。 股票买卖问题 Best Time to Buy and Sell Stock：当前的最大收益只依赖于之前的最小买入价格。因此只需要一个变量保存截至目前的最低价即可，每次更新最大收益。 Best Time to Buy and Sell Stock II：由于可以进行多次交易，那么只要明天比今天价格高就有得赚，就可以进行交易。不需要去找波峰波谷，因为day2-day1+day3-day2 == day3-day1。 可以买卖两次股票三个状态，已经买卖2次，持有 不持有股票，第k天为结束天 可以买卖k次股票三个状态，已经买卖k次，持有 不持有股票，第k天为结束天 卖出股票之后有冷冻期选择三个状态，持有股票，不持有股票，处于冷冻期 卖出股票之后有手续费选择两个状态，持有股票，不持有股票 打家劫舍粉刷房子背包九讲","path":"2020/07/12/动态规划/"},{"title":"1143. 最长公共子序列","text":"最长公共子序列最长公共子序列也是线性DP中的一种比较常见的模型。说它是一种“模型”其实有点拔高了，其实它就是一类比较常见的题目。很多题目都是在LCS的基础上进行简单的扩展，或者仅仅就是换一个说法而已。求两个数组的最长公共子序列，最直观地做法就是：设f[i][j]表示S[..i]和T[..j]的最长公共子序列，则有: f[i][j] = f[i-1][j-1] + 1 …… S[i]==T[j]f[i][j] = max(f[i-1][j], f[i][j-1]) …… S[i]≠T[j]这个转移方程也非常好理解，时间复杂度是N^2，空间复杂度也是N^2。不过仔细观察你可以发现，当我们计算第i行时只与i-1和i行有关。因此我们可以利用01滚动来优化空间复杂度为2N。 class Solution &#123; public://使用了2N的空间的动态优化 int longestCommonSubsequence(string text1, string text2) &#123; int len1=text1.size(); int len2=text2.size(); vector&lt;int&gt; a1(len2+1,0); vector&lt;int&gt; a2(len2+1,0); int flag=2; for(int i=0;i&lt;len1;i++) &#123; for(int j=0;j&lt;len2;j++) &#123; if(text1[i]==text2[j]) &#123; if(flag==2) a2[j+1]=a1[j]+1; else a1[j+1]=a2[j]+1; &#125; else &#123; if(flag==2) a2[j+1]=max(a2[j],a1[j+1]); else a1[j+1]=max(a2[j+1],a1[j]); &#125; &#125; flag=-flag; &#125; if(flag==2) return a1[len2]; else return a2[len2]; &#125; &#125;;","path":"2020/07/12/1143.最长公共子序列/"},{"title":"300. 最长上升子序列","text":"最长上升序列最长上升序列是一个非常经典的线性模型。说它是个模型，是因为它是一类题的代表，很多题目都只是换个说法，或者要求在这基础上进一步优化而已。最长上升序列最基础的转移方程就是f[i] = max{f[j]}+1 (a[i] &gt; a[j]),f[i]表示一定要以a[i]结尾的序列，最长长度是多少。很显然就是在前面找到一个最大的f[j]同时满足a[j]&lt;a[i]。因此是N^2的时间复杂度和N的空间复杂度。这种方法是最朴素直观的，一定要理解。它非常简单，因此很少有题目直接能够这么做。大部分相关题目需要进一步优化，也就是有名的单调队列优化，能够把复杂度优化到nlogn。 说单调队列优化之前必须明白一个贪心策略。因为要求的是最长上升序列，那么很显然长度为k的上升序列的最大值（最后一个数）越小越好，这样后面的数才有更大的概率比它大。如果我们记录下来不同长度的上升序列的最后一个数能达到的最小值，那么对于后续每个数t，它要么能放到某个长度为y的序列之后，组成长度为y+1的上升序列，要么放到某个长度为x的序列后面，把长度为x+1的序列的最大值替换成t。同时我们可以发现，如果x&lt;y，那么长度为x序列的最后一个数一定比长度为y的序列最后一个数小。因此这个上升序列我们可以用一个数组来维护（所谓的单调队列），数组下标就代表序列长度。opt[i]=t表示长度为i的上升序列最后一个数最小是t。那么当我们在面对后续某个数x时，可以对单调队列opt进行二分，把它插到对应的位置。因此总体复杂度就是NlogN。 class Solution &#123; public: // int lengthOfLIS(vector&lt;int&gt;&amp; nums) // &#123;//dp，不用单调队列,递推方程res[i]=max(res[j])+1 (nums[j]&lt;nums[i]) // int len=nums.size(); // if(len==0) // return 0; // vector&lt;int&gt; res(len,0); // res[0]=1; // int result=1; // for(int i=1;i&lt;len;i++) // &#123; // int maxnum=1; // for(int j=0;j&lt;i;j++) // &#123; // if(res[j]+1&gt;maxnum&amp;&amp;nums[j]&lt;nums[i]) // maxnum=res[j]+1; // &#125; // res[i]=maxnum; // if(res[i]&gt;result) // result=res[i]; // &#125; // return result; // &#125; int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;//dp，用单调队列,递推方程res[i]=max(res[j])+1 (nums[j]&lt;nums[i]) int len=nums.size(); if(len==0) return 0; vector&lt;int&gt; res; for(int i=0;i&lt;len;i++) &#123; if(res.size()==0||res[res.size()-1]&lt;nums[i]) res.push_back(nums[i]); else //if(res[res.size()-1]&lt;nums[i]) &#123; int p=BinSearch(res,nums[i]); res[p]=nums[i]; &#125; &#125; return res.size(); &#125; int BinSearch(vector&lt;int&gt;&amp; a,int b) &#123; int len=a.size(); int l=0,r=len-1; int mid=l+(r-l)/2; while(a[mid]!=b) &#123; if(r==l) return r; if(a[mid]&lt;b) &#123; l=mid+1; &#125; else &#123; r=mid; &#125; mid=mid=l+(r-l)/2; &#125; return mid; &#125; &#125;;","path":"2020/07/12/300. 最长上升子序列/"},{"title":"验证集和测试集的区别","text":"验证集和测试集 类别 验证集 测试集 是否被训练到 否 否 作用 用于调整超参数 用于验证泛化能力 使用次数 多次使用，以不断调参 仅仅一次使用 缺陷 模型在一次次重新手动调参并继续训练后所逼近的验证集，可能只代表一部分非训练集，导致最终训练好的模型泛化性能不够 测试集为了具有泛化代表性，往往数据量比较大，测试一轮要很久，所以往往只取测试集的其中一小部分作为训练过程中的验证集 互相转化 验证集具有足够泛化性（一般来说，如果验证集足够大到包括大部分非训练集时，也等于具有足够泛化性了） 验证集具有足够泛化性时，测试集就没有存在的必要了 类比 校内答辩（如果校内答辩比多校联合答辩还有泛化性说服力，那么就没有必要再搞个多校联合答辩了） 多校联合答辩 附言说到底：验证集是一定需要的；如果验证集具有足够泛化代表性，是不需要再整出什么测试集的；整个测试集往往就是为了在验证集只是非训练集一个小子集的情况下，好奇一下那个靠训练集（训练）和验证集（调参）多次接力训练出来的模型是不是具有了泛化性能，因而加试一下图个确定。","path":"2020/07/03/验证集和测试集的区别/"},{"title":"166. 分数到小数","text":"166. 分数到小数这道题我认为需要注意的有几个地方 第一个地方在于除法如何计算，这里我选择的方法是当被除数相同的时候认为是循环小数。 第二个地方在于结果可能有负数，负数的求模和正数有所不同，需要注意。负数求模是a-(a/b)*b的，有个时候因此会有正负的区分。 第三个地方在于数字溢出的问题，a=-2147483648, b=-1,a*b是会溢出的，因为会先转成一个整形的数，因此需要转一下long. 第四个地方是在判断两个数是否是同号的时候最好采用异或的方法，而不要采用相乘符号的方法，这样会导致溢出，还有一个我以前没注意的地方就是异或等位运算的优先级是要低于等于符号的，因此最好加上括号。 代码如下class Solution &#123; public: string fractionToDecimal(int numerator, int denominator) &#123; long a1=long(numerator)%denominator; long a2=long(numerator)/denominator; if(a1==0) return to_string(a2); else &#123; int i=0; int quo=abs(a2); string res=\"\"; if((numerator^denominator)&lt;0) &#123; res=res+\"-\"; i++; &#125; res=res+to_string(quo)+\".\"; i+=to_string(quo).size()-1; unordered_map&lt;int,int&gt; map; numerator=abs(a1); while(numerator!=0) &#123; numerator=abs(numerator); if(map.find(numerator)==map.end()) &#123; map[numerator]=i; i++; &#125; else &#123; string tmp=res.substr(map[numerator]+2); string tmp1=res.substr(0,map[numerator]+2); res=tmp1+\"(\"+tmp+\")\"; return res; &#125; long ttt=numerator; ttt*=10; long a=abs(ttt/denominator); long b=abs(ttt%denominator); res=res+to_string(a); numerator=b; &#125; return res; &#125; &#125; &#125;;","path":"2020/06/12/166. 分数到小数/"},{"title":"设计模式","text":"设计模式学习[toc] 设计模式和原则单一职责的原则简单的说就是软件模块应该只有一个被修改的理由。例如Spring中，我们需要有dao 层和service层，而不是把它放在一起，这样后面数据库增加字段，或者业务逻辑更改的时候就不需要修改很多东西，更容易维护。 开闭原则就是在一个模块完成的之后，就不要去改变它，最好是通过继承和多态来增加功能。所以开闭就是，对外的拓展开放，对外的修改闭合。 里氏替换原则简单的说就是尽量不要重写父类的方法，最好是只新增功能，子类可以拓展父类的功能，但是不能改变 如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。 例如几维鸟虽然生物学上是鸟，但是不会飞，如果在计算飞行的一些行为的时候，设计成继承鸟类，最后会出现错误，因此最好仔细考虑他们的继承关系，去除继承关系。 接口隔离原则接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。 要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。 接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。 依赖倒置原则依赖倒置原则的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。 由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。 使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。 在实际编程中只要遵循以下4点，就能在项目中满足这个规则。每个类尽量提供接口或抽象类，或者两者都具备。变量的声明类型尽量是接口或者是抽象类。任何类都不应该从具体类派生。使用继承时尽量遵循里氏替换原则。 创建型模式","path":"2020/06/03/设计模式/"},{"title":"ART算法实现与理解","text":"Code 这两个图显示了算法的原理，整体的几何意义也较为容易理解···import numpy as npdef ARTMy( A, b, X0, e0): e=e0+1 i=0 while(e&gt;e0): tmp=((A[i]@X0-b[i])/(np.linalg.norm(A[i]))*(A[i].T/np.linalg.norm(A[i]))) X=X0-np.reshape(tmp,(-1,1)) e=np.linalg.norm(X-X0) X0=X i=(i+1)%np.shape(A)[0] print(e) return X0if name==”_main“: A=np.array([[3,1],[1,5]]) b=np.array([[1],[1]]) e0=0.000001 X0=np.array([[0],[0]]) X=ART_My(A,b,X0,e0) print((X)) ···","path":"2020/06/03/ART算法实现与理解/"},{"title":"函数间隔和几何间隔","text":"对同一个超平面，通过比例缩放w和b，函数间隔也会同比例变化。也就是说，对于一个成功划分正负实例的超平面（不一定最优），该平面固定，但是通过缩放w和b，可以使其function margin取任何正值。而我们的目标是找到具有最大margin的超平面。显然通过最大化函数间隔没有意义，因为任何成功划分训练实例的超平面都可以使函数间隔无限大。我们注意到，对一个超平面，函数间隔与∥w∥的比值保持不变，也就是说几何间隔与超平面关联。所以，我们目标是最大化几何间隔，而且我们可以令函数间隔为1，然后最小化∥w∥达到最大化几何间隔目的。 SVM是通过超平面将样本分为两类。在超平面wx+b确定的情况下，||wx+b||可以相对地表示点距离超平面的远近。对于两类分类问题，如果wx+b&gt;0，可视为在平面上方，则的类别被判定为1；否则判定为-1。所以样本点与超平面之间的函数间隔定义为y(wx+b),但是该定义存在问题：即w和x同时缩小或放大M倍后，超平面并没有变化，但是函数间隔却变化了。w是法向量，所以，需要将w的大小固定,使得函数间隔固定。这时的间隔也就是几何间隔 。","path":"2020/05/21/函数间隔和几何间隔/"},{"title":"大端和小端","text":"字节存储顺序主要分为大端序（Big-endian）和小端序（Little-endian），区别如下Big-endian：高位字节存入低地址，低位字节存入高地址Little-endian：低位字节存入低地址，高位字节存入高地址一般来说，x86系列CPU都是Little-endian字节序，PowerPC通常是Big-endian字节序。 因为网络协议也都是采用Big-endian方式传输数据的，所以有时也把Big-endian方式称为网络字节序","path":"2020/05/20/大端和小端/"},{"title":"218. 天际线问题","text":"问题的求解方法一其实我们在题目标签看到了Line Sweep，[ 线扫描或扫描线 ] ，扫描线可以想象成一条向右扫过平面的竖直线，也是一个算法，一般是玩图形学的。 接着上面的步骤，可以通过扫描线算法将两个关键点集合进行合并。 如下图，扫描线从两个集合的起始点，同时向右移动，接触到第一个关键点，则判断这一个关键点是不是满足天际线的，如果是，则将这个关键点添加到“父”集合中；如果不是，则继续同时移动到下一个关键点。 但如何判断是否是属于“父”集合中的关键点呢？可以创建两个集合（“子”）的目前高度，然后多方角度找到满足关键点的条件。 扫描线移到[2 10]关键点时，10要大于rpre的，可以满足； 扫描线移到[3 15]关键点时，lpre此时目前的高度为10，而15要大于10的，可以满足； 扫描线移到[7 10]关键点时，rpre大于lpre可以满足，反之就不满足； 接着有一个集合已经遍历完了，剩下的集合的关键点肯定是满足的，因为没有其它的集合可以阻挡到这个集合，所以直接就是满足。 这个求解方法中的归并的写法比我以前写的要简洁一些，值得学习。这个问题的求解方法的重点在于合并两个点，合并过程中首先选择一个集合的小的，然后判断其与当前另外一个集合的当前值的关于，如果大于则一定可以加进去，因为这个值和自身高度同样也不同如果小于等于并且自身当前高度要大于另外一个集合的当前值，则可以加，否则就被盖住实际是看不到的。 在相等的情况下，我们应该考虑到相同X的位置的最高位置的不能和和此时的当前的最大位置相同，如果相同实际上是形成了一条直线，是看不到的。 class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; getSkyline(int[][] buildings) &#123; List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(buildings.length==0) return res; return divide(buildings,0,buildings.length-1); &#125; public List&lt;List&lt;Integer&gt;&gt; divide(int [][]buildings,int l,int r) &#123; List&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;(); List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(r==l) &#123; res.add(Arrays.asList(buildings[l][0],buildings[l][2])); res.add(Arrays.asList(buildings[l][1],0)); return res; &#125; int a=l+(r-l)/2; List&lt;List&lt;Integer&gt;&gt; res1=divide(buildings,l,a); List&lt;List&lt;Integer&gt;&gt; res2=divide(buildings,a+1,r); int l1=0; int r1=0; int lh=0,rh=0; int leftX, leftY, rightX, rightY; while(l1&lt;res1.size()||r1&lt;res2.size()) &#123; if(l1&gt;=res1.size()) res.add(res2.get(r1++)); else if(r1&gt;=res2.size()) res.add(res1.get(l1++)); else &#123; leftX = res1.get(l1).get(0); // 不会出现null，可以直接用int类型 leftY = res1.get(l1).get(1); rightX = res2.get(r1).get(0); rightY = res2.get(r1).get(1); if(leftX&gt;rightX)//每次选择一个较小的 &#123; if(rightY&gt;lh) res.add(res2.get(r1)); else if(rh&gt;lh) &#123; res.add(Arrays.asList(rightX,lh)); &#125; rh=rightY; r1++; &#125; else if(leftX&lt;rightX) &#123; if(leftY&gt;rh) res.add(res1.get(l1)); else if(lh&gt;rh) res.add(Arrays.asList(leftX,rh)); lh=leftY; l1++; &#125; else &#123; int h=Math.max(lh,rh); if(leftY&gt;=rightY&amp;&amp;leftY!=h) &#123; res.add(res1.get(l1)); &#125; else if(leftY&lt;=rightY&amp;&amp;rightY!=h)//只要不汇聚到最高点就没问题 &#123; res.add(res2.get(r1)); &#125; lh=leftY; rh=rightY; l1++; r1++; &#125; &#125; &#125; return res; &#125; &#125; 这个方法是扫面线算法，方法较为巧妙，左上和右上节点分别设置为负数和正数，从左加入右先队列，从右边删除出，然后每次和最大的节点进行比较，不同就加入节点。这里的java的容器的比较器的写法是o2-o1，大于0就是顺序，否则逆序。 class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; getSkyline(int[][] buildings) &#123; List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;List&lt;Integer&gt;&gt;(); Set&lt;Pair&lt;Integer,Integer&gt;&gt; pairs=new TreeSet&lt;&gt;((o1,o2)-&gt;!o1.getKey().equals(o2.getKey())?o1.getKey()-o2.getKey():o1.getValue()-o2.getValue()); for(int[] bu:buildings) &#123; pairs.add(new Pair&lt;&gt;(bu[0],-bu[2])); pairs.add(new Pair&lt;&gt;(bu[1],bu[2])); &#125; PriorityQueue&lt;Integer&gt; queue=new PriorityQueue&lt;&gt;((o1,o2)-&gt;o2-o1); int prev = 0; // 遍历 for (Pair&lt;Integer, Integer&gt; pair : pairs) &#123; if (pair.getValue() &lt; 0) queue.offer(-pair.getValue()); // 左端点 高度入堆 else queue.remove(pair.getValue()); // 右端点 高度出堆 Integer cur = queue.peek() == null ? 0 : queue.peek(); // 获取最大堆的当前顶点，当null时置为0 if (prev != cur) &#123; res.add(new ArrayList&lt;Integer&gt;() &#123; &#123; add(pair.getKey()); add(cur); &#125;&#125;); prev = cur; &#125; &#125; return res; &#125; &#125;","path":"2020/05/20/218. 天际线问题/"},{"title":"为啥那么C++pop不返回值","text":"书上的解释也就是说，为什么先用top（），然后用pop（）来访问和删除站定的元素，而不是把它们合并一个返回类型T的成员函数。 这种设计有很好的理由。如果pop（）返回栈顶元素，则必须按值返回，而不是按引用返回。按引用返回是不可行的，因为元素 在栈中已经不存在，必须在按引用返回之前现将其存储到某个地方。如果选用动态内存，除非动态内存最终被删除，否则将导致内存泄露。 按照数值返回效率很差，因为它包含对类型T的复制构造函数的调用。让pop（）返回数值将会导致潜在的内存问题或效率很低下， 因此最好让它什么数值也不返回，而是通过使用top（）来得到栈顶的数值。 从异常上看这么使用 Stack stack; stack.push(object); Object obj=stack.pop() ; 当我们执行Object obj=stack.pop() 时，Object的构造函数被调用，而这里是可以反生异常的， 假设这时候发生异常，丢生的栈顶元素就回不去了。 而在java中pop（）是有返回值的源码是这么写的 int i = size(); Object object = peek(); removeElementAt(i - 1); return (E)object; 实质上java进行对象赋值的时候是进行引用的。但是C++是进行一个复制构造函数的调用，","path":"2020/05/20/为什么C++pop不返回值/"},{"title":"145. 二叉树的后序遍历","text":"方法后序遍历的麻烦之处在于不知道现在自己是父节点的左节点还是右节点，只有知道才能决定下一步是访问右节点还是根节点，不知道的情况下就不清楚下一步应该访问弹出的栈元素的本身还是它的右节点。而前序遍历和中序遍历是总是只需要弹出栈中的元素，然后访问其右节点即可或者先访问自己再访问其右节点。 所以方法有三种： 开始的话，也是不停的往左子树走，然后直到为 null ，然后如果集合中没有栈顶元素，并且右子树不为空，那么我们就访问栈顶元素的右节点，并把栈顶元素加入集合中，如果集合中有，那么直接访问栈顶元素即可。class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res=new ArrayList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; stack=new Stack&lt;TreeNode&gt;(); Set&lt;TreeNode&gt; set=new HashSet&lt;TreeNode&gt;(); TreeNode treenode=root; while(!stack.isEmpty()||treenode!=null) &#123; if(treenode!=null) &#123; stack.push(treenode); treenode=treenode.left; &#125; else &#123; TreeNode tmp=stack.peek(); if(!set.contains(tmp)&amp;&amp;tmp.right!=null) &#123; treenode=tmp.right; set.add(tmp); &#125; else &#123; res.add(tmp.val); stack.pop(); &#125; &#125; &#125; return res; &#125; &#125; 如果当前节点的右节点和上一次遍历的节点相同，那就表明当前是从右节点过来的了class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res=new ArrayList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; stack=new Stack&lt;TreeNode&gt;(); TreeNode treenode=root; TreeNode last=null; while(!stack.isEmpty()||treenode!=null) &#123; if(treenode!=null) &#123; stack.push(treenode); treenode=treenode.left; &#125; else &#123; TreeNode tmp=stack.peek(); if(tmp.right!=null&amp;&amp;tmp.right!=last) &#123; treenode=tmp.right; &#125; else &#123; res.add(tmp.val); last=tmp; stack.pop(); &#125; &#125; &#125; return res; &#125; &#125; 只需要把每个节点 push 两次，然后判断当前 pop 节点和栈顶节点是否相同。相同的话，就意味着是从左子树到的根节点。不同的话，就意味着是从右子树到的根节点，此时就可以把节点加入到 list 中。这个方法比较巧妙 public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (root == null) &#123; return list; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); stack.push(root); while (!stack.isEmpty()) &#123; TreeNode cur = stack.pop(); if (cur == null) &#123; continue; &#125; if (!stack.isEmpty() &amp;&amp; cur == stack.peek()) &#123; stack.push(cur.right); stack.push(cur.right); stack.push(cur.left); stack.push(cur.left); &#125; else &#123; list.add(cur.val); &#125; &#125; return list; &#125; 可以转换成一个逆的前序遍历来实现public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res=new ArrayList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; stack=new Stack&lt;TreeNode&gt;(); TreeNode treenode=root; while(!stack.isEmpty()||treenode!=null) &#123; if(treenode!=null) &#123; res.add(treenode.val); stack.add(treenode); treenode=treenode.right; &#125; else &#123; treenode=stack.pop().left; &#125; &#125; Collections.reverse(res); return res; &#125;","path":"2020/05/19/145. 二叉树的后序遍历/"},{"title":"232. 用栈实现队列","text":"双栈实现队列，思路较为简单 ···class MyQueue { private Stack stack1; private Stack stack2; /* Initialize your data structure here. / public MyQueue() { stack1=new Stack(); stack2=new Stack(); } /** Push element x to the back of queue. */ public void push(int x) { stack1.push(x); } /** Removes the element from in front of queue and returns that element. */ public int pop() { if(stack2.isEmpty()) { StackMove(stack1,stack2); } int res=stack2.peek(); stack2.pop(); return res; } /** Get the front element. */ public int peek() { if(stack2.isEmpty()) { StackMove(stack1,stack2); } int res=stack2.peek(); return res; } /** Returns whether the queue is empty. */ public boolean empty() { return stack1.isEmpty()&amp;&amp;stack2.isEmpty(); } public void StackMove(Stack&lt;Integer&gt; stack1,Stack&lt;Integer&gt; stack2) { if(stack2.isEmpty()) { while(!stack1.isEmpty()) { int a=stack1.peek(); stack2.push(a); stack1.pop(); } } } } /** Your MyQueue object will be instantiated and called as such: MyQueue obj = new MyQueue(); obj.push(x); int param_2 = obj.pop(); int param_3 = obj.peek(); boolean param_4 = obj.empty();*/···","path":"2020/05/19/232. 用栈实现队列/"},{"title":"225. 用队列实现栈","text":"队列实现栈主要是栈的pop操作比较困难，这个可以通过栈的循环出队入队来实现，复杂度为O(N)。class MyStack &#123; private Queue&lt;Integer&gt; quene=new LinkedList&lt;Integer&gt;(); private int mytop=0; /** Initialize your data structure here. */ public MyStack() &#123; &#125; /** Push element x onto stack. */ public void push(int x) &#123; quene.offer(x); mytop=x; &#125; /** Removes the element on top of the stack and returns that element. */ public int pop() &#123; for(int i=0;i&lt;quene.size()-1;i++) &#123; int a=quene.poll(); quene.offer(a); if(i==quene.size()-2) mytop=a; &#125; return quene.poll(); &#125; /** Get the top element. */ public int top() &#123; if(!quene.isEmpty()) return mytop; else return 0; &#125; /** Returns whether the stack is empty. */ public boolean empty() &#123; if(quene.size()==0) return true; else return false; &#125; &#125; /** * Your MyStack object will be instantiated and called as such: * MyStack obj = new MyStack(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.top(); * boolean param_4 = obj.empty(); */","path":"2020/05/19/225. 用队列实现栈/"},{"title":"linux短横线的区别","text":"linux短横线的区别rm -vf *** tar -xzvf ***.tar.gz gcc --version rm --help 从上面命令我们可以看出，绝大数命令有以下的规则： ① 参数前单杠的表明后面的参数是字符形式； ② 参数前双杠的则表明后面的参数是单词形式 tar xzvf ***.tar.gz tar -xzvf ***.tar.gz 两种命令行都是行的通的，并且功能都是解压软件包，那它们到底有什么不同呢，实际上这就涉及两种Linux风格，System V和BSD。它们对应关系如下： ① 参数前有横的是System V风格。 ② 参数前没有横的是BSD风格。 System V和BSD两种风格的区别主要是： 系统启动过程中 kernel 最后一步调用的是 init 程序，init 程序的执行有两种风格，即 System V 和 BSD。 System V 风格中 init 调用 /etc/inittab，BSD 风格调用 /etc/rc，它们的目的相同，都是根据 runlevel 执行一系列的程序。","path":"2020/05/18/linux短横线的区别/"},{"title":"224. 基本计算器","text":"方法1和方法二：只有加减的话，相当于去掉括号，去掉括号的过程就是，把数字和字符串弹出，然后计算的过程，这个方法比较麻烦，应该可以采用字符串反向便利的方式进行计算，这样计算表达式就要方便很多，从左到右算就可以，如果还有乘除之类的话，那么在过程中应该还要判断字符的优先级，然后进行计算,还有一个需要注意的就是，数字可能有很多位。方法一： class Solution &#123; public int calculate(String s) &#123; Stack &lt;Integer&gt; op1=new Stack &lt;Integer&gt;();//数字栈 Stack&lt;Character&gt; op2=new Stack&lt;Character&gt;();//字符栈 int t=0; int flag=1;//正在记录数字 for(int i=0;i&lt;s.length();i++) &#123; Character ch=s.charAt(i); if(flag==0&amp;&amp;!Character.isDigit(ch)) &#123; op1.push(t); System.out.println(t); flag=1; t=0; &#125; if(Character.isDigit(ch)) &#123; flag=0; int num=(int)(ch-'0'); t=t*10+num; &#125; else if(ch.equals('-')||ch.equals('+')||ch.equals('(')) &#123; op2.push(ch); &#125; else if(ch.equals(')')) &#123; op1.push(CalFormula(op1,op2)); &#125; &#125; if(flag==0) &#123; op1.push(t); System.out.println(t); flag=1; t=0; &#125; return CalFormula(op1,op2); &#125; public int CalFormula(Stack &lt;Integer&gt; op1 , Stack&lt;Character&gt; op2) &#123; Stack &lt;Integer&gt; op3=new Stack &lt;Integer&gt;();//数字栈 Stack&lt;Character&gt; op4=new Stack&lt;Character&gt;();//字符栈 while(!op2.isEmpty()&amp;&amp;!op2.peek().equals('(')) &#123; op3.push(op1.peek()); op1.pop(); op4.push(op2.peek()); op2.pop(); // System.out.println(op2.peek()); &#125; op3.push(op1.peek()); op1.pop(); if(!op2.isEmpty()&amp;&amp;op2.peek().equals('(')) op2.pop(); while(!op4.isEmpty()) &#123; int a=op3.peek(); op3.pop(); int b=op3.peek(); op3.pop(); char c=op4.peek(); op4.pop(); op3.push(cal(c,a,b)); &#125; return op3.peek(); &#125; public int cal(Character ch,Integer num,Integer num1) &#123; if(ch.equals('-')) return num-num1; else return num+num1; &#125; &#125; 方法2： class Solution &#123; public int calculate(String s) &#123; Stack &lt;Integer&gt; op1=new Stack &lt;Integer&gt;();//数字栈 Stack&lt;Character&gt; op2=new Stack&lt;Character&gt;();//字符栈 Integer t=0; StringBuffer nu=new StringBuffer(\"\"); int flag=1;//正在记录数字 StringBuffer a=new StringBuffer(s); String str=a.reverse().toString(); for(int i=0;i&lt;str.length();i++) &#123; Character ch=str.charAt(i); if(flag==0&amp;&amp;!Character.isDigit(ch)) &#123; t=Integer.parseInt(nu.reverse().toString()); op1.push(t); flag=1; nu=new StringBuffer(\"\"); &#125; if(Character.isDigit(ch)) &#123; nu.append(ch); flag=0; &#125; else if(ch.equals('-')||ch.equals('+')||ch.equals(')')) &#123; op2.push(ch); &#125; else if(ch.equals('(')) &#123; CalFormula(op1,op2); &#125; &#125; if(flag==0) &#123; t=Integer.parseInt(nu.reverse().toString()); op1.push(t); &#125; return CalFormula(op1,op2); &#125; public int CalFormula(Stack &lt;Integer&gt; op1 , Stack&lt;Character&gt; op2) &#123; Stack &lt;Integer&gt; op3=new Stack &lt;Integer&gt;();//数字栈 Stack&lt;Character&gt; op4=new Stack&lt;Character&gt;();//字符栈 while(!op2.isEmpty()&amp;&amp;!op2.peek().equals(')')) &#123; int a=op1.peek(); op1.pop(); int b=op1.peek(); op1.pop(); Character c=op2.peek(); op2.pop(); op1.push(cal(c,a,b)); &#125; if(!op2.isEmpty()&amp;&amp;op2.peek().equals(')')) op2.pop(); return op1.peek(); &#125; public int cal(Character ch,Integer num,Integer num1) &#123; if(ch.equals('-')) return num-num1; else return num+num1; &#125; &#125; 方法三采用一种双栈的方法，解法一经过了一个中间过程，先转为了后缀表达式然后进行求值。我们其实可以直接利用两个栈，边遍历边进行的，这个方法是我当时上课学的方法。从 这里 把过程贴到下边，和解法一其实有些类似的。 使用两个栈，stack0 用于存储操作数，stack1 用于存储操作符从左往右扫描，遇到操作数入栈 stack0遇到操作符时，如果当前优先级低于或等于栈顶操作符优先级，则从 stack0 弹出两个元素，从 stack1 弹出一个操作符，进行计算，将结果并压入stack0，继续与栈顶操作符的比较优先级。如果遇到操作符高于栈顶操作符优先级，则直接入栈 stack1遇到左括号，直接入栈 stack1。遇到右括号，则从 stack0 弹出两个元素，从 stack1 弹出一个操作符进行计算，并将结果加入到 stack0 中，重复这步直到遇到左括号和解法一一样，因为我们只有加法和减法，所以这个流程可以简化一下。 第 3 条改成「遇到操作符时，则从 stack0 弹出两个元素进行计算，并压入stack0，直到栈空或者遇到左括号，最后将当前操作符压入 stack1 」处。class Solution &#123; public int calculate(String s) &#123; Stack &lt;Integer&gt; op1=new Stack &lt;Integer&gt;();//数字栈 Stack&lt;Character&gt; op2=new Stack&lt;Character&gt;();//字符栈 HashMap&lt;Character,Integer&gt; map=new HashMap&lt;Character,Integer&gt;(); map.put('+',1); map.put('-',1); map.put('(',-1); Integer t=0; int flag=1; Character ch; for(int i=0;i&lt;s.length();i++) &#123; ch=s.charAt(i); if(flag==0&amp;&amp;!Character.isDigit(ch)) &#123; op1.push(t); t=0; flag=1; &#125; if(Character.isDigit(ch)) &#123; flag=0; t=t*10+(int)(ch-'0'); &#125; else if(ch.equals('-')||ch.equals('+')) &#123; flag=1; while(!op2.isEmpty()&amp;&amp;!(map.get(op2.peek())&lt;map.get(ch))) &#123; int a=op1.peek(); op1.pop(); int b=op1.peek(); op1.pop(); Character c=op2.peek(); op2.pop(); op1.push(cal(c,b,a)); &#125; op2.push(ch); &#125; else if(ch.equals('(')) &#123; flag=1; op2.push(ch); &#125; else if(ch.equals(')')) &#123; flag=1; while(!op2.isEmpty()&amp;&amp;!op2.peek().equals('(')) &#123; int a=op1.peek(); op1.pop(); int b=op1.peek(); op1.pop(); Character c=op2.peek(); op2.pop(); op1.push(cal(c,b,a)); &#125; op2.pop(); &#125; &#125; if(flag==0) &#123; op1.push(t); &#125; while(!op2.isEmpty()) &#123; int a=op1.peek(); op1.pop(); int b=op1.peek(); op1.pop(); Character c=op2.peek(); op2.pop(); op1.push(cal(c,b,a)); &#125; return op1.peek(); &#125; public int cal(Character ch,Integer num,Integer num1) &#123; if(ch.equals('-')) return num-num1; else return num+num1; &#125; &#125;","path":"2020/05/18/224. 基本计算器/"},{"title":"统计学习方法课后作业","text":"第九章EM算法及其推广9.1 import numpy as np y=[1,1,0,1,0,0,1,0,1,1] pai=0.46 p=0.55 q=0.67 theta=2 while(theta&gt;0.0001): u_next=[] for i in range(len(y)): a=pai*(p**y[i])*((1-p)**(1-y[i])) b=(1-pai)*(q**y[i])*((1-q)**(1-y[i])) u_next.append(a/(a+b)) pai_next=0 p_next=0 q_next=0 tmp=0 pai_next=np.mean(u_next) p_next = sum(np.multiply(u_next,y))/sum(u_next) tmp=[1-u_next[i] for i in range(len(y))] q_next = sum(np.multiply(tmp,y))/sum(tmp) print(pai_next) print(p_next) print(q_next) print(\"\\n\") theta=abs(pai_next-pai)+abs(p_next-p)+abs(q_next-q) pai=pai_next p=p_next q=q_next 求得0.461862835113919 0.5345950037850112 0.6561346417857326 0.46186283511391907 0.5345950037850112 0.6561346417857326","path":"2020/05/18/统计学习方法课后作业/"},{"title":"神经网络初始化与xavier初始化","text":"xavier初始化 深度学习初始化总结","path":"2020/05/18/神经网络初始化与xavier初始化/"},{"title":"矩阵的范数","text":"关于矩阵的范数的一些总结 一范数，二范数，闵可夫斯基范数这些都比较常见，一般不用多说 核范数代表矩阵的奇异值之和，是用来约束低秩的一种范数，代表rank(w)的凸近似。 ||X||_*=\\sum_{i}^{}\\sigma_i(x)F范数即为就是对应元素的平方和再开方。f范数实际上就是衡量这个矩阵和对应的零矩阵的距离，","path":"2020/05/18/矩阵的范数/"},{"title":"矩阵求导","text":"参考文章","path":"2020/05/18/矩阵求导/"},{"title":"在hexo博客中写数学公式","text":"这个网站值得借鉴","path":"2020/05/18/在hexo博客中写数学公式/"},{"title":"图像的k空间","text":"关于图像的k空间到底是什么意思呢，总的来说就算傅里叶域变换后的一种图，不能让人感性的感受到图，但是经过傅里叶反变换，总是能够变回原来的图像具体可见下面两篇博客k空间k空间","path":"2020/05/18/图像的k空间/"},{"title":"矩阵的TV最小化","text":"在一个图像处理问题中如何有效的去除图像的噪声可以求解这样一个问题最小化图像的TV,TV即为梯度图像的一范数，当然需要加上正则化项，如果不加的化，全黑图才是最优的一个解，加上正则化之后可以获得图像的分块光滑图像，事实证明，效果很好。","path":"2020/05/18/TV最小化/"},{"title":"softmax和SVM损失函数","text":"softmax可以参考softmax可以参考 softmax可以参考主要要理解熵的原理，以及交叉熵。以及softmax的正则化的内容 SVM损失函数可以参考SVM损失函数可以参考主要是要比正确分类的类别多出一个边界出来","path":"2020/05/18/softmax和SVM损失函数/"},{"title":"Numpy中矩阵与向量的加法","text":"在Numpy中，矩阵与向量相加时，矩阵的每一行与向量相加，即要求矩阵的列数与向量的维数相等。import numpy as np x = np.array([[1, 2, 3], [4, 5, 6]]) # array([[1, 2, 3], # [4, 5, 6]]) y = np.array([1, 2]) # array([1, 2]) z = np.array([1, 2, 3]) # array([1, 2, 3]) # x + y 会报错 x + z # array([[2, 4, 6], # [5, 7, 9]])","path":"2020/05/18/numpy矩阵加法/"},{"title":"matlab并行","text":"parfor matlab用法matlab会弄出几个虚拟的小pc，一个算i=1:30部分循环,一个算i=50:80部分循环,再来一个算i=90:120部分循环，当然数字是我瞎编的，我是想说matlab将一个大循环分成小块，然后这些小块并行计算，最后再合在一起。这样，有一个问题，因为普通的循环是从i=1算到i=100，一个接一个算，如果下一次循环要依赖上一次循环怎么办？如果出现这种情况，那就不能用matlab的parfor了。用parfor的前提条件就是，循环的每次迭代独立，不相互依赖。举个简单的例子，计算1+2+3...+100就可以用parfor，但是如果计算斐波那契数列的前100个数字，那就不能用parfor了。","path":"2020/05/18/matlab并行/"},{"title":"makedown数学公式写法","text":"此网站可以查看公式写法","path":"2020/05/18/makedown数学公式写法/"},{"title":"conda 安装 pytorch","text":"关于conda安装pytorch的一些问题的总结 使用conda安装pytorch较为简单在pytorch官网选择自己需要的版本，以及是否带gpu的，我的由于是没有gpu的，所以是conda install pytorch torchvision cpuonly -c pytorch 但是下载的速度会很慢，而且会出现httperror,这时可以考虑更换源，选择国内的镜像源，例如清华的镜像更换镜像conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --set show_channel_urls yes conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ 测试是否安装成功import torch 成功后代表安装成功 更多信息: 我的博客","path":"2020/05/18/hello-world/"},{"title":"使用github+hexo部署博客","text":"可见这篇博客 更多信息: 我的博客","path":"2020/05/18/github+hexo博客搭建/"},{"title":"图像生成","text":"可以参考这个博客图像生成cs231 同时这个人还总结了cs231的很多内容，可以都参考一下","path":"2020/05/18/cs231图像生成/"}],"categories":[],"tags":[]}