{"meta":{"title":"TheSakura's Blog","subtitle":null,"description":null,"author":"chenxiang","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about-me","text":"","path":"about-me/index.html"},{"title":"tags","text":"","path":"tags/index.html"},{"title":"categories","text":"","path":"categories/index.html"}],"posts":[{"title":"300. 最长上升子序列","text":"最长上升序列最长上升序列是一个非常经典的线性模型。说它是个模型，是因为它是一类题的代表，很多题目都只是换个说法，或者要求在这基础上进一步优化而已。最长上升序列最基础的转移方程就是f[i] = max{f[j]}+1 (a[i] &gt; a[j]),f[i]表示一定要以a[i]结尾的序列，最长长度是多少。很显然就是在前面找到一个最大的f[j]同时满足a[j]&lt;a[i]。因此是N^2的时间复杂度和N的空间复杂度。这种方法是最朴素直观的，一定要理解。它非常简单，因此很少有题目直接能够这么做。大部分相关题目需要进一步优化，也就是有名的单调队列优化，能够把复杂度优化到nlogn。 说单调队列优化之前必须明白一个贪心策略。因为要求的是最长上升序列，那么很显然长度为k的上升序列的最大值（最后一个数）越小越好，这样后面的数才有更大的概率比它大。如果我们记录下来不同长度的上升序列的最后一个数能达到的最小值，那么对于后续每个数t，它要么能放到某个长度为y的序列之后，组成长度为y+1的上升序列，要么放到某个长度为x的序列后面，把长度为x+1的序列的最大值替换成t。同时我们可以发现，如果x&lt;y，那么长度为x序列的最后一个数一定比长度为y的序列最后一个数小。因此这个上升序列我们可以用一个数组来维护（所谓的单调队列），数组下标就代表序列长度。opt[i]=t表示长度为i的上升序列最后一个数最小是t。那么当我们在面对后续某个数x时，可以对单调队列opt进行二分，把它插到对应的位置。因此总体复杂度就是NlogN。 class Solution &#123; public: // int lengthOfLIS(vector&lt;int&gt;&amp; nums) // &#123;//dp，不用单调队列,递推方程res[i]=max(res[j])+1 (nums[j]&lt;nums[i]) // int len=nums.size(); // if(len==0) // return 0; // vector&lt;int&gt; res(len,0); // res[0]=1; // int result=1; // for(int i=1;i&lt;len;i++) // &#123; // int maxnum=1; // for(int j=0;j&lt;i;j++) // &#123; // if(res[j]+1&gt;maxnum&amp;&amp;nums[j]&lt;nums[i]) // maxnum=res[j]+1; // &#125; // res[i]=maxnum; // if(res[i]&gt;result) // result=res[i]; // &#125; // return result; // &#125; int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;//dp，用单调队列,递推方程res[i]=max(res[j])+1 (nums[j]&lt;nums[i]) int len=nums.size(); if(len==0) return 0; vector&lt;int&gt; res; for(int i=0;i&lt;len;i++) &#123; if(res.size()==0||res[res.size()-1]&lt;nums[i]) res.push_back(nums[i]); else //if(res[res.size()-1]&lt;nums[i]) &#123; int p=BinSearch(res,nums[i]); res[p]=nums[i]; &#125; &#125; return res.size(); &#125; int BinSearch(vector&lt;int&gt;&amp; a,int b) &#123; int len=a.size(); int l=0,r=len-1; int mid=l+(r-l)/2; while(a[mid]!=b) &#123; if(r==l) return r; if(a[mid]&lt;b) &#123; l=mid+1; &#125; else &#123; r=mid; &#125; mid=mid=l+(r-l)/2; &#125; return mid; &#125; &#125;;","path":"2020/07/12/300. 最长上升子序列/"},{"title":"验证集和测试集的区别","text":"验证集和测试集 类别 验证集 测试集 是否被训练到 否 否 作用 用于调整超参数 用于验证泛化能力 使用次数 多次使用，以不断调参 仅仅一次使用 缺陷 模型在一次次重新手动调参并继续训练后所逼近的验证集，可能只代表一部分非训练集，导致最终训练好的模型泛化性能不够 测试集为了具有泛化代表性，往往数据量比较大，测试一轮要很久，所以往往只取测试集的其中一小部分作为训练过程中的验证集 互相转化 验证集具有足够泛化性（一般来说，如果验证集足够大到包括大部分非训练集时，也等于具有足够泛化性了） 验证集具有足够泛化性时，测试集就没有存在的必要了 类比 校内答辩（如果校内答辩比多校联合答辩还有泛化性说服力，那么就没有必要再搞个多校联合答辩了） 多校联合答辩 附言说到底：验证集是一定需要的；如果验证集具有足够泛化代表性，是不需要再整出什么测试集的；整个测试集往往就是为了在验证集只是非训练集一个小子集的情况下，好奇一下那个靠训练集（训练）和验证集（调参）多次接力训练出来的模型是不是具有了泛化性能，因而加试一下图个确定。","path":"2020/07/03/验证集和测试集的区别/"},{"title":"166. 分数到小数","text":"166. 分数到小数这道题我认为需要注意的有几个地方 第一个地方在于除法如何计算，这里我选择的方法是当被除数相同的时候认为是循环小数。 第二个地方在于结果可能有负数，负数的求模和正数有所不同，需要注意。负数求模是a-(a/b)*b的，有个时候因此会有正负的区分。 第三个地方在于数字溢出的问题，a=-2147483648, b=-1,a*b是会溢出的，因为会先转成一个整形的数，因此需要转一下long. 第四个地方是在判断两个数是否是同号的时候最好采用异或的方法，而不要采用相乘符号的方法，这样会导致溢出，还有一个我以前没注意的地方就是异或等位运算的优先级是要低于等于符号的，因此最好加上括号。 代码如下class Solution &#123; public: string fractionToDecimal(int numerator, int denominator) &#123; long a1=long(numerator)%denominator; long a2=long(numerator)/denominator; if(a1==0) return to_string(a2); else &#123; int i=0; int quo=abs(a2); string res=\"\"; if((numerator^denominator)&lt;0) &#123; res=res+\"-\"; i++; &#125; res=res+to_string(quo)+\".\"; i+=to_string(quo).size()-1; unordered_map&lt;int,int&gt; map; numerator=abs(a1); while(numerator!=0) &#123; numerator=abs(numerator); if(map.find(numerator)==map.end()) &#123; map[numerator]=i; i++; &#125; else &#123; string tmp=res.substr(map[numerator]+2); string tmp1=res.substr(0,map[numerator]+2); res=tmp1+\"(\"+tmp+\")\"; return res; &#125; long ttt=numerator; ttt*=10; long a=abs(ttt/denominator); long b=abs(ttt%denominator); res=res+to_string(a); numerator=b; &#125; return res; &#125; &#125; &#125;;","path":"2020/06/12/166. 分数到小数/"},{"title":"设计模式","text":"设计模式学习[toc] 设计模式和原则单一职责的原则简单的说就是软件模块应该只有一个被修改的理由。例如Spring中，我们需要有dao 层和service层，而不是把它放在一起，这样后面数据库增加字段，或者业务逻辑更改的时候就不需要修改很多东西，更容易维护。 开闭原则就是在一个模块完成的之后，就不要去改变它，最好是通过继承和多态来增加功能。所以开闭就是，对外的拓展开放，对外的修改闭合。 里氏替换原则简单的说就是尽量不要重写父类的方法，最好是只新增功能，子类可以拓展父类的功能，但是不能改变 如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。 例如几维鸟虽然生物学上是鸟，但是不会飞，如果在计算飞行的一些行为的时候，设计成继承鸟类，最后会出现错误，因此最好仔细考虑他们的继承关系，去除继承关系。 接口隔离原则接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。 要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。 接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。 依赖倒置原则依赖倒置原则的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。 由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。 使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。 在实际编程中只要遵循以下4点，就能在项目中满足这个规则。每个类尽量提供接口或抽象类，或者两者都具备。变量的声明类型尽量是接口或者是抽象类。任何类都不应该从具体类派生。使用继承时尽量遵循里氏替换原则。 创建型模式","path":"2020/06/03/设计模式/"},{"title":"ART算法实现与理解","text":"Code 这两个图显示了算法的原理，整体的几何意义也较为容易理解···import numpy as npdef ARTMy( A, b, X0, e0): e=e0+1 i=0 while(e&gt;e0): tmp=((A[i]@X0-b[i])/(np.linalg.norm(A[i]))*(A[i].T/np.linalg.norm(A[i]))) X=X0-np.reshape(tmp,(-1,1)) e=np.linalg.norm(X-X0) X0=X i=(i+1)%np.shape(A)[0] print(e) return X0if name==”_main“: A=np.array([[3,1],[1,5]]) b=np.array([[1],[1]]) e0=0.000001 X0=np.array([[0],[0]]) X=ART_My(A,b,X0,e0) print((X)) ···","path":"2020/06/03/ART算法实现与理解/"},{"title":"函数间隔和几何间隔","text":"对同一个超平面，通过比例缩放w和b，函数间隔也会同比例变化。也就是说，对于一个成功划分正负实例的超平面（不一定最优），该平面固定，但是通过缩放w和b，可以使其function margin取任何正值。而我们的目标是找到具有最大margin的超平面。显然通过最大化函数间隔没有意义，因为任何成功划分训练实例的超平面都可以使函数间隔无限大。我们注意到，对一个超平面，函数间隔与∥w∥的比值保持不变，也就是说几何间隔与超平面关联。所以，我们目标是最大化几何间隔，而且我们可以令函数间隔为1，然后最小化∥w∥达到最大化几何间隔目的。 SVM是通过超平面将样本分为两类。在超平面wx+b确定的情况下，||wx+b||可以相对地表示点距离超平面的远近。对于两类分类问题，如果wx+b&gt;0，可视为在平面上方，则的类别被判定为1；否则判定为-1。所以样本点与超平面之间的函数间隔定义为y(wx+b),但是该定义存在问题：即w和x同时缩小或放大M倍后，超平面并没有变化，但是函数间隔却变化了。w是法向量，所以，需要将w的大小固定,使得函数间隔固定。这时的间隔也就是几何间隔 。","path":"2020/05/21/函数间隔和几何间隔/"},{"title":"大端和小端","text":"字节存储顺序主要分为大端序（Big-endian）和小端序（Little-endian），区别如下Big-endian：高位字节存入低地址，低位字节存入高地址Little-endian：低位字节存入低地址，高位字节存入高地址一般来说，x86系列CPU都是Little-endian字节序，PowerPC通常是Big-endian字节序。 因为网络协议也都是采用Big-endian方式传输数据的，所以有时也把Big-endian方式称为网络字节序","path":"2020/05/20/大端和小端/"},{"title":"218. 天际线问题","text":"问题的求解方法一其实我们在题目标签看到了Line Sweep，[ 线扫描或扫描线 ] ，扫描线可以想象成一条向右扫过平面的竖直线，也是一个算法，一般是玩图形学的。 接着上面的步骤，可以通过扫描线算法将两个关键点集合进行合并。 如下图，扫描线从两个集合的起始点，同时向右移动，接触到第一个关键点，则判断这一个关键点是不是满足天际线的，如果是，则将这个关键点添加到“父”集合中；如果不是，则继续同时移动到下一个关键点。 但如何判断是否是属于“父”集合中的关键点呢？可以创建两个集合（“子”）的目前高度，然后多方角度找到满足关键点的条件。 扫描线移到[2 10]关键点时，10要大于rpre的，可以满足； 扫描线移到[3 15]关键点时，lpre此时目前的高度为10，而15要大于10的，可以满足； 扫描线移到[7 10]关键点时，rpre大于lpre可以满足，反之就不满足； 接着有一个集合已经遍历完了，剩下的集合的关键点肯定是满足的，因为没有其它的集合可以阻挡到这个集合，所以直接就是满足。 这个求解方法中的归并的写法比我以前写的要简洁一些，值得学习。这个问题的求解方法的重点在于合并两个点，合并过程中首先选择一个集合的小的，然后判断其与当前另外一个集合的当前值的关于，如果大于则一定可以加进去，因为这个值和自身高度同样也不同如果小于等于并且自身当前高度要大于另外一个集合的当前值，则可以加，否则就被盖住实际是看不到的。 在相等的情况下，我们应该考虑到相同X的位置的最高位置的不能和和此时的当前的最大位置相同，如果相同实际上是形成了一条直线，是看不到的。 class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; getSkyline(int[][] buildings) &#123; List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(buildings.length==0) return res; return divide(buildings,0,buildings.length-1); &#125; public List&lt;List&lt;Integer&gt;&gt; divide(int [][]buildings,int l,int r) &#123; List&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;(); List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(r==l) &#123; res.add(Arrays.asList(buildings[l][0],buildings[l][2])); res.add(Arrays.asList(buildings[l][1],0)); return res; &#125; int a=l+(r-l)/2; List&lt;List&lt;Integer&gt;&gt; res1=divide(buildings,l,a); List&lt;List&lt;Integer&gt;&gt; res2=divide(buildings,a+1,r); int l1=0; int r1=0; int lh=0,rh=0; int leftX, leftY, rightX, rightY; while(l1&lt;res1.size()||r1&lt;res2.size()) &#123; if(l1&gt;=res1.size()) res.add(res2.get(r1++)); else if(r1&gt;=res2.size()) res.add(res1.get(l1++)); else &#123; leftX = res1.get(l1).get(0); // 不会出现null，可以直接用int类型 leftY = res1.get(l1).get(1); rightX = res2.get(r1).get(0); rightY = res2.get(r1).get(1); if(leftX&gt;rightX)//每次选择一个较小的 &#123; if(rightY&gt;lh) res.add(res2.get(r1)); else if(rh&gt;lh) &#123; res.add(Arrays.asList(rightX,lh)); &#125; rh=rightY; r1++; &#125; else if(leftX&lt;rightX) &#123; if(leftY&gt;rh) res.add(res1.get(l1)); else if(lh&gt;rh) res.add(Arrays.asList(leftX,rh)); lh=leftY; l1++; &#125; else &#123; int h=Math.max(lh,rh); if(leftY&gt;=rightY&amp;&amp;leftY!=h) &#123; res.add(res1.get(l1)); &#125; else if(leftY&lt;=rightY&amp;&amp;rightY!=h)//只要不汇聚到最高点就没问题 &#123; res.add(res2.get(r1)); &#125; lh=leftY; rh=rightY; l1++; r1++; &#125; &#125; &#125; return res; &#125; &#125; 这个方法是扫面线算法，方法较为巧妙，左上和右上节点分别设置为负数和正数，从左加入右先队列，从右边删除出，然后每次和最大的节点进行比较，不同就加入节点。这里的java的容器的比较器的写法是o2-o1，大于0就是顺序，否则逆序。 class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; getSkyline(int[][] buildings) &#123; List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;List&lt;Integer&gt;&gt;(); Set&lt;Pair&lt;Integer,Integer&gt;&gt; pairs=new TreeSet&lt;&gt;((o1,o2)-&gt;!o1.getKey().equals(o2.getKey())?o1.getKey()-o2.getKey():o1.getValue()-o2.getValue()); for(int[] bu:buildings) &#123; pairs.add(new Pair&lt;&gt;(bu[0],-bu[2])); pairs.add(new Pair&lt;&gt;(bu[1],bu[2])); &#125; PriorityQueue&lt;Integer&gt; queue=new PriorityQueue&lt;&gt;((o1,o2)-&gt;o2-o1); int prev = 0; // 遍历 for (Pair&lt;Integer, Integer&gt; pair : pairs) &#123; if (pair.getValue() &lt; 0) queue.offer(-pair.getValue()); // 左端点 高度入堆 else queue.remove(pair.getValue()); // 右端点 高度出堆 Integer cur = queue.peek() == null ? 0 : queue.peek(); // 获取最大堆的当前顶点，当null时置为0 if (prev != cur) &#123; res.add(new ArrayList&lt;Integer&gt;() &#123; &#123; add(pair.getKey()); add(cur); &#125;&#125;); prev = cur; &#125; &#125; return res; &#125; &#125;","path":"2020/05/20/218. 天际线问题/"},{"title":"为啥那么C++pop不返回值","text":"书上的解释也就是说，为什么先用top（），然后用pop（）来访问和删除站定的元素，而不是把它们合并一个返回类型T的成员函数。 这种设计有很好的理由。如果pop（）返回栈顶元素，则必须按值返回，而不是按引用返回。按引用返回是不可行的，因为元素 在栈中已经不存在，必须在按引用返回之前现将其存储到某个地方。如果选用动态内存，除非动态内存最终被删除，否则将导致内存泄露。 按照数值返回效率很差，因为它包含对类型T的复制构造函数的调用。让pop（）返回数值将会导致潜在的内存问题或效率很低下， 因此最好让它什么数值也不返回，而是通过使用top（）来得到栈顶的数值。 从异常上看这么使用 Stack stack; stack.push(object); Object obj=stack.pop() ; 当我们执行Object obj=stack.pop() 时，Object的构造函数被调用，而这里是可以反生异常的， 假设这时候发生异常，丢生的栈顶元素就回不去了。 而在java中pop（）是有返回值的源码是这么写的 int i = size(); Object object = peek(); removeElementAt(i - 1); return (E)object; 实质上java进行对象赋值的时候是进行引用的。但是C++是进行一个复制构造函数的调用，","path":"2020/05/20/为什么C++pop不返回值/"},{"title":"145. 二叉树的后序遍历","text":"方法后序遍历的麻烦之处在于不知道现在自己是父节点的左节点还是右节点，只有知道才能决定下一步是访问右节点还是根节点，不知道的情况下就不清楚下一步应该访问弹出的栈元素的本身还是它的右节点。而前序遍历和中序遍历是总是只需要弹出栈中的元素，然后访问其右节点即可或者先访问自己再访问其右节点。 所以方法有三种： 开始的话，也是不停的往左子树走，然后直到为 null ，然后如果集合中没有栈顶元素，并且右子树不为空，那么我们就访问栈顶元素的右节点，并把栈顶元素加入集合中，如果集合中有，那么直接访问栈顶元素即可。class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res=new ArrayList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; stack=new Stack&lt;TreeNode&gt;(); Set&lt;TreeNode&gt; set=new HashSet&lt;TreeNode&gt;(); TreeNode treenode=root; while(!stack.isEmpty()||treenode!=null) &#123; if(treenode!=null) &#123; stack.push(treenode); treenode=treenode.left; &#125; else &#123; TreeNode tmp=stack.peek(); if(!set.contains(tmp)&amp;&amp;tmp.right!=null) &#123; treenode=tmp.right; set.add(tmp); &#125; else &#123; res.add(tmp.val); stack.pop(); &#125; &#125; &#125; return res; &#125; &#125; 如果当前节点的右节点和上一次遍历的节点相同，那就表明当前是从右节点过来的了class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res=new ArrayList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; stack=new Stack&lt;TreeNode&gt;(); TreeNode treenode=root; TreeNode last=null; while(!stack.isEmpty()||treenode!=null) &#123; if(treenode!=null) &#123; stack.push(treenode); treenode=treenode.left; &#125; else &#123; TreeNode tmp=stack.peek(); if(tmp.right!=null&amp;&amp;tmp.right!=last) &#123; treenode=tmp.right; &#125; else &#123; res.add(tmp.val); last=tmp; stack.pop(); &#125; &#125; &#125; return res; &#125; &#125; 只需要把每个节点 push 两次，然后判断当前 pop 节点和栈顶节点是否相同。相同的话，就意味着是从左子树到的根节点。不同的话，就意味着是从右子树到的根节点，此时就可以把节点加入到 list 中。这个方法比较巧妙 public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (root == null) &#123; return list; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); stack.push(root); while (!stack.isEmpty()) &#123; TreeNode cur = stack.pop(); if (cur == null) &#123; continue; &#125; if (!stack.isEmpty() &amp;&amp; cur == stack.peek()) &#123; stack.push(cur.right); stack.push(cur.right); stack.push(cur.left); stack.push(cur.left); &#125; else &#123; list.add(cur.val); &#125; &#125; return list; &#125; 可以转换成一个逆的前序遍历来实现public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res=new ArrayList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; stack=new Stack&lt;TreeNode&gt;(); TreeNode treenode=root; while(!stack.isEmpty()||treenode!=null) &#123; if(treenode!=null) &#123; res.add(treenode.val); stack.add(treenode); treenode=treenode.right; &#125; else &#123; treenode=stack.pop().left; &#125; &#125; Collections.reverse(res); return res; &#125;","path":"2020/05/19/145. 二叉树的后序遍历/"},{"title":"232. 用栈实现队列","text":"双栈实现队列，思路较为简单 ···class MyQueue { private Stack stack1; private Stack stack2; /* Initialize your data structure here. / public MyQueue() { stack1=new Stack(); stack2=new Stack(); } /** Push element x to the back of queue. */ public void push(int x) { stack1.push(x); } /** Removes the element from in front of queue and returns that element. */ public int pop() { if(stack2.isEmpty()) { StackMove(stack1,stack2); } int res=stack2.peek(); stack2.pop(); return res; } /** Get the front element. */ public int peek() { if(stack2.isEmpty()) { StackMove(stack1,stack2); } int res=stack2.peek(); return res; } /** Returns whether the queue is empty. */ public boolean empty() { return stack1.isEmpty()&amp;&amp;stack2.isEmpty(); } public void StackMove(Stack&lt;Integer&gt; stack1,Stack&lt;Integer&gt; stack2) { if(stack2.isEmpty()) { while(!stack1.isEmpty()) { int a=stack1.peek(); stack2.push(a); stack1.pop(); } } } } /** Your MyQueue object will be instantiated and called as such: MyQueue obj = new MyQueue(); obj.push(x); int param_2 = obj.pop(); int param_3 = obj.peek(); boolean param_4 = obj.empty();*/···","path":"2020/05/19/232. 用栈实现队列/"},{"title":"225. 用队列实现栈","text":"队列实现栈主要是栈的pop操作比较困难，这个可以通过栈的循环出队入队来实现，复杂度为O(N)。class MyStack &#123; private Queue&lt;Integer&gt; quene=new LinkedList&lt;Integer&gt;(); private int mytop=0; /** Initialize your data structure here. */ public MyStack() &#123; &#125; /** Push element x onto stack. */ public void push(int x) &#123; quene.offer(x); mytop=x; &#125; /** Removes the element on top of the stack and returns that element. */ public int pop() &#123; for(int i=0;i&lt;quene.size()-1;i++) &#123; int a=quene.poll(); quene.offer(a); if(i==quene.size()-2) mytop=a; &#125; return quene.poll(); &#125; /** Get the top element. */ public int top() &#123; if(!quene.isEmpty()) return mytop; else return 0; &#125; /** Returns whether the stack is empty. */ public boolean empty() &#123; if(quene.size()==0) return true; else return false; &#125; &#125; /** * Your MyStack object will be instantiated and called as such: * MyStack obj = new MyStack(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.top(); * boolean param_4 = obj.empty(); */","path":"2020/05/19/225. 用队列实现栈/"},{"title":"linux短横线的区别","text":"linux短横线的区别rm -vf *** tar -xzvf ***.tar.gz gcc --version rm --help 从上面命令我们可以看出，绝大数命令有以下的规则： ① 参数前单杠的表明后面的参数是字符形式； ② 参数前双杠的则表明后面的参数是单词形式 tar xzvf ***.tar.gz tar -xzvf ***.tar.gz 两种命令行都是行的通的，并且功能都是解压软件包，那它们到底有什么不同呢，实际上这就涉及两种Linux风格，System V和BSD。它们对应关系如下： ① 参数前有横的是System V风格。 ② 参数前没有横的是BSD风格。 System V和BSD两种风格的区别主要是： 系统启动过程中 kernel 最后一步调用的是 init 程序，init 程序的执行有两种风格，即 System V 和 BSD。 System V 风格中 init 调用 /etc/inittab，BSD 风格调用 /etc/rc，它们的目的相同，都是根据 runlevel 执行一系列的程序。","path":"2020/05/18/linux短横线的区别/"},{"title":"224. 基本计算器","text":"方法1和方法二：只有加减的话，相当于去掉括号，去掉括号的过程就是，把数字和字符串弹出，然后计算的过程，这个方法比较麻烦，应该可以采用字符串反向便利的方式进行计算，这样计算表达式就要方便很多，从左到右算就可以，如果还有乘除之类的话，那么在过程中应该还要判断字符的优先级，然后进行计算,还有一个需要注意的就是，数字可能有很多位。方法一： class Solution &#123; public int calculate(String s) &#123; Stack &lt;Integer&gt; op1=new Stack &lt;Integer&gt;();//数字栈 Stack&lt;Character&gt; op2=new Stack&lt;Character&gt;();//字符栈 int t=0; int flag=1;//正在记录数字 for(int i=0;i&lt;s.length();i++) &#123; Character ch=s.charAt(i); if(flag==0&amp;&amp;!Character.isDigit(ch)) &#123; op1.push(t); System.out.println(t); flag=1; t=0; &#125; if(Character.isDigit(ch)) &#123; flag=0; int num=(int)(ch-'0'); t=t*10+num; &#125; else if(ch.equals('-')||ch.equals('+')||ch.equals('(')) &#123; op2.push(ch); &#125; else if(ch.equals(')')) &#123; op1.push(CalFormula(op1,op2)); &#125; &#125; if(flag==0) &#123; op1.push(t); System.out.println(t); flag=1; t=0; &#125; return CalFormula(op1,op2); &#125; public int CalFormula(Stack &lt;Integer&gt; op1 , Stack&lt;Character&gt; op2) &#123; Stack &lt;Integer&gt; op3=new Stack &lt;Integer&gt;();//数字栈 Stack&lt;Character&gt; op4=new Stack&lt;Character&gt;();//字符栈 while(!op2.isEmpty()&amp;&amp;!op2.peek().equals('(')) &#123; op3.push(op1.peek()); op1.pop(); op4.push(op2.peek()); op2.pop(); // System.out.println(op2.peek()); &#125; op3.push(op1.peek()); op1.pop(); if(!op2.isEmpty()&amp;&amp;op2.peek().equals('(')) op2.pop(); while(!op4.isEmpty()) &#123; int a=op3.peek(); op3.pop(); int b=op3.peek(); op3.pop(); char c=op4.peek(); op4.pop(); op3.push(cal(c,a,b)); &#125; return op3.peek(); &#125; public int cal(Character ch,Integer num,Integer num1) &#123; if(ch.equals('-')) return num-num1; else return num+num1; &#125; &#125; 方法2： class Solution &#123; public int calculate(String s) &#123; Stack &lt;Integer&gt; op1=new Stack &lt;Integer&gt;();//数字栈 Stack&lt;Character&gt; op2=new Stack&lt;Character&gt;();//字符栈 Integer t=0; StringBuffer nu=new StringBuffer(\"\"); int flag=1;//正在记录数字 StringBuffer a=new StringBuffer(s); String str=a.reverse().toString(); for(int i=0;i&lt;str.length();i++) &#123; Character ch=str.charAt(i); if(flag==0&amp;&amp;!Character.isDigit(ch)) &#123; t=Integer.parseInt(nu.reverse().toString()); op1.push(t); flag=1; nu=new StringBuffer(\"\"); &#125; if(Character.isDigit(ch)) &#123; nu.append(ch); flag=0; &#125; else if(ch.equals('-')||ch.equals('+')||ch.equals(')')) &#123; op2.push(ch); &#125; else if(ch.equals('(')) &#123; CalFormula(op1,op2); &#125; &#125; if(flag==0) &#123; t=Integer.parseInt(nu.reverse().toString()); op1.push(t); &#125; return CalFormula(op1,op2); &#125; public int CalFormula(Stack &lt;Integer&gt; op1 , Stack&lt;Character&gt; op2) &#123; Stack &lt;Integer&gt; op3=new Stack &lt;Integer&gt;();//数字栈 Stack&lt;Character&gt; op4=new Stack&lt;Character&gt;();//字符栈 while(!op2.isEmpty()&amp;&amp;!op2.peek().equals(')')) &#123; int a=op1.peek(); op1.pop(); int b=op1.peek(); op1.pop(); Character c=op2.peek(); op2.pop(); op1.push(cal(c,a,b)); &#125; if(!op2.isEmpty()&amp;&amp;op2.peek().equals(')')) op2.pop(); return op1.peek(); &#125; public int cal(Character ch,Integer num,Integer num1) &#123; if(ch.equals('-')) return num-num1; else return num+num1; &#125; &#125; 方法三采用一种双栈的方法，解法一经过了一个中间过程，先转为了后缀表达式然后进行求值。我们其实可以直接利用两个栈，边遍历边进行的，这个方法是我当时上课学的方法。从 这里 把过程贴到下边，和解法一其实有些类似的。 使用两个栈，stack0 用于存储操作数，stack1 用于存储操作符从左往右扫描，遇到操作数入栈 stack0遇到操作符时，如果当前优先级低于或等于栈顶操作符优先级，则从 stack0 弹出两个元素，从 stack1 弹出一个操作符，进行计算，将结果并压入stack0，继续与栈顶操作符的比较优先级。如果遇到操作符高于栈顶操作符优先级，则直接入栈 stack1遇到左括号，直接入栈 stack1。遇到右括号，则从 stack0 弹出两个元素，从 stack1 弹出一个操作符进行计算，并将结果加入到 stack0 中，重复这步直到遇到左括号和解法一一样，因为我们只有加法和减法，所以这个流程可以简化一下。 第 3 条改成「遇到操作符时，则从 stack0 弹出两个元素进行计算，并压入stack0，直到栈空或者遇到左括号，最后将当前操作符压入 stack1 」处。class Solution &#123; public int calculate(String s) &#123; Stack &lt;Integer&gt; op1=new Stack &lt;Integer&gt;();//数字栈 Stack&lt;Character&gt; op2=new Stack&lt;Character&gt;();//字符栈 HashMap&lt;Character,Integer&gt; map=new HashMap&lt;Character,Integer&gt;(); map.put('+',1); map.put('-',1); map.put('(',-1); Integer t=0; int flag=1; Character ch; for(int i=0;i&lt;s.length();i++) &#123; ch=s.charAt(i); if(flag==0&amp;&amp;!Character.isDigit(ch)) &#123; op1.push(t); t=0; flag=1; &#125; if(Character.isDigit(ch)) &#123; flag=0; t=t*10+(int)(ch-'0'); &#125; else if(ch.equals('-')||ch.equals('+')) &#123; flag=1; while(!op2.isEmpty()&amp;&amp;!(map.get(op2.peek())&lt;map.get(ch))) &#123; int a=op1.peek(); op1.pop(); int b=op1.peek(); op1.pop(); Character c=op2.peek(); op2.pop(); op1.push(cal(c,b,a)); &#125; op2.push(ch); &#125; else if(ch.equals('(')) &#123; flag=1; op2.push(ch); &#125; else if(ch.equals(')')) &#123; flag=1; while(!op2.isEmpty()&amp;&amp;!op2.peek().equals('(')) &#123; int a=op1.peek(); op1.pop(); int b=op1.peek(); op1.pop(); Character c=op2.peek(); op2.pop(); op1.push(cal(c,b,a)); &#125; op2.pop(); &#125; &#125; if(flag==0) &#123; op1.push(t); &#125; while(!op2.isEmpty()) &#123; int a=op1.peek(); op1.pop(); int b=op1.peek(); op1.pop(); Character c=op2.peek(); op2.pop(); op1.push(cal(c,b,a)); &#125; return op1.peek(); &#125; public int cal(Character ch,Integer num,Integer num1) &#123; if(ch.equals('-')) return num-num1; else return num+num1; &#125; &#125;","path":"2020/05/18/224. 基本计算器/"},{"title":"统计学习方法课后作业","text":"第九章EM算法及其推广9.1 import numpy as np y=[1,1,0,1,0,0,1,0,1,1] pai=0.46 p=0.55 q=0.67 theta=2 while(theta&gt;0.0001): u_next=[] for i in range(len(y)): a=pai*(p**y[i])*((1-p)**(1-y[i])) b=(1-pai)*(q**y[i])*((1-q)**(1-y[i])) u_next.append(a/(a+b)) pai_next=0 p_next=0 q_next=0 tmp=0 pai_next=np.mean(u_next) p_next = sum(np.multiply(u_next,y))/sum(u_next) tmp=[1-u_next[i] for i in range(len(y))] q_next = sum(np.multiply(tmp,y))/sum(tmp) print(pai_next) print(p_next) print(q_next) print(\"\\n\") theta=abs(pai_next-pai)+abs(p_next-p)+abs(q_next-q) pai=pai_next p=p_next q=q_next 求得0.461862835113919 0.5345950037850112 0.6561346417857326 0.46186283511391907 0.5345950037850112 0.6561346417857326","path":"2020/05/18/统计学习方法课后作业/"},{"title":"神经网络初始化与xavier初始化","text":"xavier初始化 深度学习初始化总结","path":"2020/05/18/神经网络初始化与xavier初始化/"},{"title":"矩阵的范数","text":"关于矩阵的范数的一些总结 一范数，二范数，闵可夫斯基范数这些都比较常见，一般不用多说 核范数代表矩阵的奇异值之和，是用来约束低秩的一种范数，代表rank(w)的凸近似。 ||X||_*=\\sum_{i}^{}\\sigma_i(x)F范数即为就是对应元素的平方和再开方。f范数实际上就是衡量这个矩阵和对应的零矩阵的距离，","path":"2020/05/18/矩阵的范数/"},{"title":"矩阵求导","text":"参考文章","path":"2020/05/18/矩阵求导/"},{"title":"在hexo博客中写数学公式","text":"这个网站值得借鉴","path":"2020/05/18/在hexo博客中写数学公式/"},{"title":"图像的k空间","text":"关于图像的k空间到底是什么意思呢，总的来说就算傅里叶域变换后的一种图，不能让人感性的感受到图，但是经过傅里叶反变换，总是能够变回原来的图像具体可见下面两篇博客k空间k空间","path":"2020/05/18/图像的k空间/"},{"title":"矩阵的TV最小化","text":"在一个图像处理问题中如何有效的去除图像的噪声可以求解这样一个问题最小化图像的TV,TV即为梯度图像的一范数，当然需要加上正则化项，如果不加的化，全黑图才是最优的一个解，加上正则化之后可以获得图像的分块光滑图像，事实证明，效果很好。","path":"2020/05/18/TV最小化/"},{"title":"softmax和SVM损失函数","text":"softmax可以参考softmax可以参考 softmax可以参考主要要理解熵的原理，以及交叉熵。以及softmax的正则化的内容 SVM损失函数可以参考SVM损失函数可以参考主要是要比正确分类的类别多出一个边界出来","path":"2020/05/18/softmax和SVM损失函数/"},{"title":"Numpy中矩阵与向量的加法","text":"在Numpy中，矩阵与向量相加时，矩阵的每一行与向量相加，即要求矩阵的列数与向量的维数相等。import numpy as np x = np.array([[1, 2, 3], [4, 5, 6]]) # array([[1, 2, 3], # [4, 5, 6]]) y = np.array([1, 2]) # array([1, 2]) z = np.array([1, 2, 3]) # array([1, 2, 3]) # x + y 会报错 x + z # array([[2, 4, 6], # [5, 7, 9]])","path":"2020/05/18/numpy矩阵加法/"},{"title":"matlab并行","text":"parfor matlab用法matlab会弄出几个虚拟的小pc，一个算i=1:30部分循环,一个算i=50:80部分循环,再来一个算i=90:120部分循环，当然数字是我瞎编的，我是想说matlab将一个大循环分成小块，然后这些小块并行计算，最后再合在一起。这样，有一个问题，因为普通的循环是从i=1算到i=100，一个接一个算，如果下一次循环要依赖上一次循环怎么办？如果出现这种情况，那就不能用matlab的parfor了。用parfor的前提条件就是，循环的每次迭代独立，不相互依赖。举个简单的例子，计算1+2+3...+100就可以用parfor，但是如果计算斐波那契数列的前100个数字，那就不能用parfor了。","path":"2020/05/18/matlab并行/"},{"title":"makedown数学公式写法","text":"此网站可以查看公式写法","path":"2020/05/18/makedown数学公式写法/"},{"title":"conda 安装 pytorch","text":"关于conda安装pytorch的一些问题的总结 使用conda安装pytorch较为简单在pytorch官网选择自己需要的版本，以及是否带gpu的，我的由于是没有gpu的，所以是conda install pytorch torchvision cpuonly -c pytorch 但是下载的速度会很慢，而且会出现httperror,这时可以考虑更换源，选择国内的镜像源，例如清华的镜像更换镜像conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --set show_channel_urls yes conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ 测试是否安装成功import torch 成功后代表安装成功 更多信息: 我的博客","path":"2020/05/18/hello-world/"},{"title":"使用github+hexo部署博客","text":"可见这篇博客 更多信息: 我的博客","path":"2020/05/18/github+hexo博客搭建/"},{"title":"图像生成","text":"可以参考这个博客图像生成cs231 同时这个人还总结了cs231的很多内容，可以都参考一下","path":"2020/05/18/cs231图像生成/"}],"categories":[],"tags":[]}