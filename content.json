{"meta":{"title":"TheSakura's Blog","subtitle":null,"description":null,"author":"chenxiang","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about-me","text":"","path":"about-me/index.html"},{"title":"categories","text":"","path":"categories/index.html"},{"title":"tags","text":"","path":"tags/index.html"}],"posts":[{"title":"224. 基本计算器","text":"方法1和方法二：只有加减的话，相当于去掉括号，去掉括号的过程就是，把数字和字符串弹出，然后计算的过程，这个方法比较麻烦，应该可以采用字符串反向便利的方式进行计算，这样计算表达式就要方便很多，从左到右算就可以，如果还有乘除之类的话，那么在过程中应该还要判断字符的优先级，然后进行计算,还有一个需要注意的就是，数字可能有很多位。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182方法一：class Solution &#123; public int calculate(String s) &#123; Stack &lt;Integer&gt; op1&#x3D;new Stack &lt;Integer&gt;();&#x2F;&#x2F;数字栈 Stack&lt;Character&gt; op2&#x3D;new Stack&lt;Character&gt;();&#x2F;&#x2F;字符栈 int t&#x3D;0; int flag&#x3D;1;&#x2F;&#x2F;正在记录数字 for(int i&#x3D;0;i&lt;s.length();i++) &#123; Character ch&#x3D;s.charAt(i); if(flag&#x3D;&#x3D;0&amp;&amp;!Character.isDigit(ch)) &#123; op1.push(t); System.out.println(t); flag&#x3D;1; t&#x3D;0; &#125; if(Character.isDigit(ch)) &#123; flag&#x3D;0; int num&#x3D;(int)(ch-&#39;0&#39;); t&#x3D;t*10+num; &#125; else if(ch.equals(&#39;-&#39;)||ch.equals(&#39;+&#39;)||ch.equals(&#39;(&#39;)) &#123; op2.push(ch); &#125; else if(ch.equals(&#39;)&#39;)) &#123; op1.push(CalFormula(op1,op2)); &#125; &#125; if(flag&#x3D;&#x3D;0) &#123; op1.push(t); System.out.println(t); flag&#x3D;1; t&#x3D;0; &#125; return CalFormula(op1,op2); &#125; public int CalFormula(Stack &lt;Integer&gt; op1 , Stack&lt;Character&gt; op2) &#123; Stack &lt;Integer&gt; op3&#x3D;new Stack &lt;Integer&gt;();&#x2F;&#x2F;数字栈 Stack&lt;Character&gt; op4&#x3D;new Stack&lt;Character&gt;();&#x2F;&#x2F;字符栈 while(!op2.isEmpty()&amp;&amp;!op2.peek().equals(&#39;(&#39;)) &#123; op3.push(op1.peek()); op1.pop(); op4.push(op2.peek()); op2.pop(); &#x2F;&#x2F; System.out.println(op2.peek()); &#125; op3.push(op1.peek()); op1.pop(); if(!op2.isEmpty()&amp;&amp;op2.peek().equals(&#39;(&#39;)) op2.pop(); while(!op4.isEmpty()) &#123; int a&#x3D;op3.peek(); op3.pop(); int b&#x3D;op3.peek(); op3.pop(); char c&#x3D;op4.peek(); op4.pop(); op3.push(cal(c,a,b)); &#125; return op3.peek(); &#125; public int cal(Character ch,Integer num,Integer num1) &#123; if(ch.equals(&#39;-&#39;)) return num-num1; else return num+num1; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869方法2：class Solution &#123; public int calculate(String s) &#123; Stack &lt;Integer&gt; op1&#x3D;new Stack &lt;Integer&gt;();&#x2F;&#x2F;数字栈 Stack&lt;Character&gt; op2&#x3D;new Stack&lt;Character&gt;();&#x2F;&#x2F;字符栈 Integer t&#x3D;0; StringBuffer nu&#x3D;new StringBuffer(&quot;&quot;); int flag&#x3D;1;&#x2F;&#x2F;正在记录数字 StringBuffer a&#x3D;new StringBuffer(s); String str&#x3D;a.reverse().toString(); for(int i&#x3D;0;i&lt;str.length();i++) &#123; Character ch&#x3D;str.charAt(i); if(flag&#x3D;&#x3D;0&amp;&amp;!Character.isDigit(ch)) &#123; t&#x3D;Integer.parseInt(nu.reverse().toString()); op1.push(t); flag&#x3D;1; nu&#x3D;new StringBuffer(&quot;&quot;); &#125; if(Character.isDigit(ch)) &#123; nu.append(ch); flag&#x3D;0; &#125; else if(ch.equals(&#39;-&#39;)||ch.equals(&#39;+&#39;)||ch.equals(&#39;)&#39;)) &#123; op2.push(ch); &#125; else if(ch.equals(&#39;(&#39;)) &#123; CalFormula(op1,op2); &#125; &#125; if(flag&#x3D;&#x3D;0) &#123; t&#x3D;Integer.parseInt(nu.reverse().toString()); op1.push(t); &#125; return CalFormula(op1,op2); &#125; public int CalFormula(Stack &lt;Integer&gt; op1 , Stack&lt;Character&gt; op2) &#123; Stack &lt;Integer&gt; op3&#x3D;new Stack &lt;Integer&gt;();&#x2F;&#x2F;数字栈 Stack&lt;Character&gt; op4&#x3D;new Stack&lt;Character&gt;();&#x2F;&#x2F;字符栈 while(!op2.isEmpty()&amp;&amp;!op2.peek().equals(&#39;)&#39;)) &#123; int a&#x3D;op1.peek(); op1.pop(); int b&#x3D;op1.peek(); op1.pop(); Character c&#x3D;op2.peek(); op2.pop(); op1.push(cal(c,a,b)); &#125; if(!op2.isEmpty()&amp;&amp;op2.peek().equals(&#39;)&#39;)) op2.pop(); return op1.peek(); &#125; public int cal(Character ch,Integer num,Integer num1) &#123; if(ch.equals(&#39;-&#39;)) return num-num1; else return num+num1; &#125;&#125; 方法三采用一种双栈的方法，解法一经过了一个中间过程，先转为了后缀表达式然后进行求值。我们其实可以直接利用两个栈，边遍历边进行的，这个方法是我当时上课学的方法。从 这里 把过程贴到下边，和解法一其实有些类似的。 使用两个栈，stack0 用于存储操作数，stack1 用于存储操作符从左往右扫描，遇到操作数入栈 stack0遇到操作符时，如果当前优先级低于或等于栈顶操作符优先级，则从 stack0 弹出两个元素，从 stack1 弹出一个操作符，进行计算，将结果并压入stack0，继续与栈顶操作符的比较优先级。如果遇到操作符高于栈顶操作符优先级，则直接入栈 stack1遇到左括号，直接入栈 stack1。遇到右括号，则从 stack0 弹出两个元素，从 stack1 弹出一个操作符进行计算，并将结果加入到 stack0 中，重复这步直到遇到左括号和解法一一样，因为我们只有加法和减法，所以这个流程可以简化一下。 第 3 条改成「遇到操作符时，则从 stack0 弹出两个元素进行计算，并压入stack0，直到栈空或者遇到左括号，最后将当前操作符压入 stack1 」处。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687class Solution &#123; public int calculate(String s) &#123; Stack &lt;Integer&gt; op1&#x3D;new Stack &lt;Integer&gt;();&#x2F;&#x2F;数字栈 Stack&lt;Character&gt; op2&#x3D;new Stack&lt;Character&gt;();&#x2F;&#x2F;字符栈 HashMap&lt;Character,Integer&gt; map&#x3D;new HashMap&lt;Character,Integer&gt;(); map.put(&#39;+&#39;,1); map.put(&#39;-&#39;,1); map.put(&#39;(&#39;,-1); Integer t&#x3D;0; int flag&#x3D;1; Character ch; for(int i&#x3D;0;i&lt;s.length();i++) &#123; ch&#x3D;s.charAt(i); if(flag&#x3D;&#x3D;0&amp;&amp;!Character.isDigit(ch)) &#123; op1.push(t); t&#x3D;0; flag&#x3D;1; &#125; if(Character.isDigit(ch)) &#123; flag&#x3D;0; t&#x3D;t*10+(int)(ch-&#39;0&#39;); &#125; else if(ch.equals(&#39;-&#39;)||ch.equals(&#39;+&#39;)) &#123; flag&#x3D;1; while(!op2.isEmpty()&amp;&amp;!(map.get(op2.peek())&lt;map.get(ch))) &#123; int a&#x3D;op1.peek(); op1.pop(); int b&#x3D;op1.peek(); op1.pop(); Character c&#x3D;op2.peek(); op2.pop(); op1.push(cal(c,b,a)); &#125; op2.push(ch); &#125; else if(ch.equals(&#39;(&#39;)) &#123; flag&#x3D;1; op2.push(ch); &#125; else if(ch.equals(&#39;)&#39;)) &#123; flag&#x3D;1; while(!op2.isEmpty()&amp;&amp;!op2.peek().equals(&#39;(&#39;)) &#123; int a&#x3D;op1.peek(); op1.pop(); int b&#x3D;op1.peek(); op1.pop(); Character c&#x3D;op2.peek(); op2.pop(); op1.push(cal(c,b,a)); &#125; op2.pop(); &#125; &#125; if(flag&#x3D;&#x3D;0) &#123; op1.push(t); &#125; while(!op2.isEmpty()) &#123; int a&#x3D;op1.peek(); op1.pop(); int b&#x3D;op1.peek(); op1.pop(); Character c&#x3D;op2.peek(); op2.pop(); op1.push(cal(c,b,a)); &#125; return op1.peek(); &#125; public int cal(Character ch,Integer num,Integer num1) &#123; if(ch.equals(&#39;-&#39;)) return num-num1; else return num+num1; &#125;&#125;","path":"2020/05/18/224. 基本计算器/"},{"title":"统计学习方法课后作业","text":"第九章EM算法及其推广123456789101112131415161718192021222324252627282930319.1import numpy as npy&#x3D;[1,1,0,1,0,0,1,0,1,1]pai&#x3D;0.46p&#x3D;0.55q&#x3D;0.67theta&#x3D;2while(theta&gt;0.0001): u_next&#x3D;[] for i in range(len(y)): a&#x3D;pai*(p**y[i])*((1-p)**(1-y[i])) b&#x3D;(1-pai)*(q**y[i])*((1-q)**(1-y[i])) u_next.append(a&#x2F;(a+b)) pai_next&#x3D;0 p_next&#x3D;0 q_next&#x3D;0 tmp&#x3D;0 pai_next&#x3D;np.mean(u_next) p_next &#x3D; sum(np.multiply(u_next,y))&#x2F;sum(u_next) tmp&#x3D;[1-u_next[i] for i in range(len(y))] q_next &#x3D; sum(np.multiply(tmp,y))&#x2F;sum(tmp) print(pai_next) print(p_next) print(q_next) print(&quot;\\n&quot;) theta&#x3D;abs(pai_next-pai)+abs(p_next-p)+abs(q_next-q) pai&#x3D;pai_next p&#x3D;p_next q&#x3D;q_next 求得123456780.4618628351139190.53459500378501120.65613464178573260.461862835113919070.53459500378501120.6561346417857326","path":"2020/05/18/统计学习方法课后作业/"},{"title":"神经网络初始化与xavier初始化","text":"xavier初始化 深度学习初始化总结","path":"2020/05/18/神经网络初始化与xavier初始化/"},{"title":"矩阵的范数","text":"关于矩阵的范数的一些总结 一范数，二范数，闵可夫斯基范数这些都比较常见，一般不用多说 核范数代表矩阵的奇异值之和，是用来约束低秩的一种范数，代表rank(w)的凸近似。 ||X||_*=\\sum_{i}^{}\\sigma_i(x)F范数即为就是对应元素的平方和再开方。f范数实际上就是衡量这个矩阵和对应的零矩阵的距离，","path":"2020/05/18/矩阵的范数/"},{"title":"矩阵求导","text":"参考文章","path":"2020/05/18/矩阵求导/"},{"title":"在hexo博客中写数学公式","text":"这个网站值得借鉴","path":"2020/05/18/在hexo博客中写数学公式/"},{"title":"图像的k空间","text":"关于图像的k空间到底是什么意思呢，总的来说就算傅里叶域变换后的一种图，不能让人感性的感受到图，但是经过傅里叶反变换，总是能够变回原来的图像具体可见下面两篇博客k空间k空间","path":"2020/05/18/图像的k空间/"},{"title":"矩阵的TV最小化","text":"在一个图像处理问题中如何有效的去除图像的噪声可以求解这样一个问题最小化图像的TV,TV即为梯度图像的一范数，当然需要加上正则化项，如果不加的化，全黑图才是最优的一个解，加上正则化之后可以获得图像的分块光滑图像，事实证明，效果很好。","path":"2020/05/18/TV最小化/"},{"title":"softmax和SVM损失函数","text":"softmax可以参考softmax可以参考 softmax可以参考1主要要理解熵的原理，以及交叉熵。以及softmax的正则化的内容 SVM损失函数可以参考SVM损失函数可以参考1主要是要比正确分类的类别多出一个边界出来","path":"2020/05/18/softmax和SVM损失函数/"},{"title":"Numpy中矩阵与向量的加法","text":"在Numpy中，矩阵与向量相加时，矩阵的每一行与向量相加，即要求矩阵的列数与向量的维数相等。1234567891011121314import numpy as npx &#x3D; np.array([[1, 2, 3], [4, 5, 6]])# array([[1, 2, 3],# [4, 5, 6]])y &#x3D; np.array([1, 2])# array([1, 2])z &#x3D; np.array([1, 2, 3])# array([1, 2, 3])# x + y 会报错x + z# array([[2, 4, 6],# [5, 7, 9]])","path":"2020/05/18/numpy矩阵加法/"},{"title":"matlab并行","text":"parfor matlab用法1matlab会弄出几个虚拟的小pc，一个算i&#x3D;1:30部分循环,一个算i&#x3D;50:80部分循环,再来一个算i&#x3D;90:120部分循环，当然数字是我瞎编的，我是想说matlab将一个大循环分成小块，然后这些小块并行计算，最后再合在一起。这样，有一个问题，因为普通的循环是从i&#x3D;1算到i&#x3D;100，一个接一个算，如果下一次循环要依赖上一次循环怎么办？如果出现这种情况，那就不能用matlab的parfor了。用parfor的前提条件就是，循环的每次迭代独立，不相互依赖。举个简单的例子，计算1+2+3...+100就可以用parfor，但是如果计算斐波那契数列的前100个数字，那就不能用parfor了。","path":"2020/05/18/matlab并行/"},{"title":"makedown数学公式写法","text":"此网站可以查看公式写法","path":"2020/05/18/makedown数学公式写法/"},{"title":"conda 安装 pytorch","text":"关于conda安装pytorch的一些问题的总结 使用conda安装pytorch较为简单在pytorch官网选择自己需要的版本，以及是否带gpu的，我的由于是没有gpu的，所以是1conda install pytorch torchvision cpuonly -c pytorch 但是下载的速度会很慢，而且会出现httperror,这时可以考虑更换源，选择国内的镜像源，例如清华的镜像更换镜像1234conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --set show_channel_urls yesconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ 测试是否安装成功1import torch 成功后代表安装成功 更多信息: 我的博客","path":"2020/05/18/hello-world/"},{"title":"使用github+hexo部署博客","text":"可见这篇博客 更多信息: 我的博客","path":"2020/05/18/github+hexo博客搭建/"},{"title":"图像生成","text":"可以参考这个博客图像生成cs231 同时这个人还总结了cs231的很多内容，可以都参考一下","path":"2020/05/18/cs231图像生成/"}],"categories":[],"tags":[]}